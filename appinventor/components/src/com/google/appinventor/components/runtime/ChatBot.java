// -*- mode: java; c-basic-offset: 2; -*-
// Copyright 2023 MIT, All rights reserved
// Released under the Apache License, Version 2.0
// http://www.apache.org/licenses/LICENSE-2.0

/*
 * Chat Bot Component, based on the Translator Component
 * @author jis@mit.edu (Jeffrey I. Schiller)
 *
 */

package com.google.appinventor.components.runtime;

import android.graphics.Bitmap;
import android.graphics.drawable.BitmapDrawable;
import android.util.Log;

import com.google.appinventor.common.version.AppInventorFeatures;

import com.google.appinventor.components.annotations.DesignerComponent;
import com.google.appinventor.components.annotations.DesignerProperty;
import com.google.appinventor.components.annotations.PropertyCategory;
import com.google.appinventor.components.annotations.Provider;
import com.google.appinventor.components.annotations.ProviderModel;
import com.google.appinventor.components.annotations.SimpleEvent;
import com.google.appinventor.components.annotations.SimpleFunction;
import com.google.appinventor.components.annotations.SimpleObject;
import com.google.appinventor.components.annotations.SimpleProperty;
import com.google.appinventor.components.annotations.UsesLibraries;
import com.google.appinventor.components.annotations.UsesPermissions;

import com.google.appinventor.components.common.ComponentCategory;
import com.google.appinventor.components.common.PropertyTypeConstants;
import com.google.appinventor.components.common.YaVersion;

import com.google.appinventor.components.runtime.chatbot.ChatBotToken;
import com.google.appinventor.components.runtime.errors.StopBlocksExecution;

import com.google.appinventor.components.runtime.util.AsynchUtil;
import com.google.appinventor.components.runtime.util.Base58Util;
import com.google.appinventor.components.runtime.util.ErrorMessages;
import com.google.appinventor.components.runtime.util.HttpUtil;
import com.google.appinventor.components.runtime.util.MediaUtil;
import com.google.protobuf.ByteString;

import java.io.ByteArrayOutputStream;
import java.io.IOException;

import jsinterop.annotations.JsMethod;
import jsinterop.annotations.JsProperty;

/**
 * The ChatBot component is a non-visible component for chatting with an AI
 * chatbot. This version uses a proxy run by MIT that in turn uses the ChatGPT
 * generative large language model.
 *
 * @author jis@mit.edu (Jeffrey I. Schiller)
 */

@DesignerComponent(version = YaVersion.CHATBOT_COMPONENT_VERSION,
    description = "A Non-visible component for communicating with an AI chat " +
  "bot. This component currently communicates with a proxy run by MIT which in turn " +
  "uses OpenAI's ChatGPT API. This component is considered experimental.",
    category = ComponentCategory.EXPERIMENTAL,
    nonVisible = true,
    iconName = "images/chatbot.png")
@UsesPermissions(permissionNames = "android.permission.INTERNET")
@UsesLibraries(libraries = "protobuf-java-3.0.0.jar")
@SimpleObject
public final class ChatBot extends AndroidNonvisibleComponent {

  private static final String CHATBOT_SERVICE_URL = AppInventorFeatures.chatBotHost() + "chat/v1";
  private static final String LOG_TAG = "ChatBot";
  private static final boolean DEBUG = false;

  private String apiKey;        // User supplied actual ChatGPT API key
  private String model = "";    // Model to use, provider dependent
  private String provider = "chatgpt";      // The provider to use (default chatgpt)
                                                  // SSL
  private String system = "";   // The "System" string for ChatGPT
  private String token = "";    // MIT Access Token, generated by MockChatBot
  private String uuid = "";     // The UUID for continuing conversations
  private int size = 256;

  /**
   * Creates a new component.
   *
   * @param container  container, component will be placed in
   */
  public ChatBot(ComponentContainer container) {
    super(container.$form());
  }

  @SimpleFunction(description = "Reset the current conversation, Chat bot will forget " +
    "any previous conversation when responding in the future.")
  @JsMethod(name = "ResetConversation")
  public void ResetConversation() {
    this.uuid = "";
  }

  @SimpleFunction(description = "Ask a question of the Chat Bot. Successive calls will " +
    "remember information from earlier in the conversation. Use the \"ResetConversation\" " +
    "function to reset for a new conversation.")
  @JsMethod(name = "Converse")
  public void Converse(final String question) {

    AsynchUtil.runAsynchronously(new Runnable() {
      @Override
      public void run() {
        performRequest(uuid, question, null);
      }
      });
  }

  private void performRequest(String uuid, String question, Bitmap image) {
    // languageToTransateTo is provided either as a two letter code, or two
    // two letter codes separated by a dash. If only one two letter code is
    // provided, it is the target language and we set the source language to auto
    // which tells the service to detect the language

    /* Convert Bitmap to an image String suitable to send to the ChatBot proxy */
    ByteString imageString = null;
    if (image != null) {
      ByteArrayOutputStream imageBuffer = new ByteArrayOutputStream();
      image.compress(Bitmap.CompressFormat.PNG, 100, imageBuffer);
      imageString = ByteString.copyFrom(imageBuffer.toByteArray());
    }

    String iToken;
    int responseCode = -1;   // A reasonable default
    try {
      Log.d(LOG_TAG, "performRequest: apiKey = " + apiKey);
      if (!token.equals("") && token.substring(0, 1).equals("%")) {
        iToken = token.substring(1);
      } else {
        iToken = token;
      }
      byte [] decodedToken = Base58Util.decode(iToken);
      ChatBotToken.token token = ChatBotToken.token.parseFrom(decodedToken);
      ChatBotToken.request.Builder builder = ChatBotToken.request.newBuilder()
        .setToken(token)
        .setUuid(uuid)
        .setProvider(provider)
        .setQuestion(question);
      if (!system.equals("") && uuid.equals("")) {
        builder = builder.setSystem(system);
      }
      if (apiKey != null && !apiKey.equals("")) {
        builder = builder.setApikey(apiKey);
      }
      if (!model.isEmpty()) {
        builder.setModel(model);
      }
      if (imageString != null) {
        builder.setInputimage(imageString);
      }
      ChatBotToken.request request = builder.build();

      HttpUtil.post(LOG_TAG, CHATBOT_SERVICE_URL, request.toByteArray(), new HttpUtil.HttpCallback() {
        @Override
        public void onResponse(int responseCode, byte[] content, String error) {
          if (error != null) {
            ErrorOccurred(responseCode, error);
            return;
          }
          try {
            ChatBotToken.response response = ChatBotToken.response.parseFrom(content);
            String returnText;
            if (responseCode == 200) {
              returnText = response.getAnswer();
              ChatBot.this.uuid = response.getUuid();
              GotResponse(returnText);
            }
          } catch (Exception e) {
            Log.e(LOG_TAG, "Error parsing response from ChatBot", e);
            ErrorOccurred(responseCode, "Error parsing response from ChatBot");
          }
        }
      });
    } catch (Exception e) {
      ErrorOccurred(responseCode, "Error talking to ChatBot proxy");
    }
  }

  @SimpleFunction(description = "Ask a question of the Chat Bot using an Image. Successive calls will " +
    "remember information from earlier in the conversation. Use the \"ResetConversation\" " +
    "function to reset for a new conversation.")
  @JsMethod(name = "ConverseWithImage")
  public void ConverseWithImage(final String question, final Object source) {
    try {
      final Bitmap bitmap = loadImage(source);
      if (bitmap != null) {
        AsynchUtil.runAsynchronously(new Runnable() {
          @Override
          public void run() {
            performRequest(uuid, question, bitmap);
          }
        });
      } else {
        form.androidUIHandler.postDelayed(new Runnable() {
          @Override
          public void run() {
            ErrorOccurred(-1, "Invalid input to ChatBot");
          }
        }, 0);
        throw new StopBlocksExecution();
      }
    } catch (IOException e) {
      Log.e(LOG_TAG, "Unable to read image", e);
    }
  }

  /**
   * Event indicating that a request has finished and has returned data (output from ChatBot).
   *
   * @param responseText the response content from the server
   */
  @SimpleEvent(description = "Event fired when the Chat Bot answers a question.")
  public void GotResponse(final String responseText) {
    form.runOnUiThread(new Runnable() {
        @Override
        public void run() {
          EventDispatcher.dispatchEvent(ChatBot.this, "GotResponse", responseText);
        }
      });
  }

  /**
   * The "System" value. Used by ChatGPT. Example: "You are a funny person"
   * It sets the tone for the conversation.
   */

  @SimpleProperty(category = PropertyCategory.BEHAVIOR,
    description = "The \"System\" value given to ChatGPT. It is " +
    "used to set the tone of a conversation. For example: \"You are a funny person.\"",
    userVisible = true)
  @JsProperty(name = "System")
  public String System() {
    return system;
  }

  @DesignerProperty(editorType = PropertyTypeConstants.PROPERTY_TYPE_TEXTAREA,
    defaultValue = "")
  @SimpleProperty(description = "The \"System\" value given to ChatGPT. It is " +
    "used to set the tone of a conversation. For example: \"You are a funny person.\"",
    userVisible = true)
  @JsProperty(name = "System")
  public void System(String system) {
    this.system = system;
  }

  /**
   * The MIT Access token to use. MIT App Inventor will automatically fill this
   * value in. You should not need to change it.
   *
   */

  @DesignerProperty(editorType = PropertyTypeConstants.PROPERTY_TYPE_STRING,
      defaultValue = "")
  @SimpleProperty(description = "The MIT Access token to use. MIT App Inventor will automatically fill this " +
    "value in. You should not need to change it.",
    userVisible = true, category = PropertyCategory.ADVANCED)
  @JsProperty(name = "Token")
  public void Token(String token) {
    this.token = token;
  }

  /**
   * An ApiKey for ChatGPT. User supplied. If provided, we will use it instead of the
   * API key embedded in the chat proxy service.
   *
   * Note: We do not provide this as a DesignerProperty, it should be stored using the
   * blocks, preferably using the Obfuscated Text block to provide some protection
   * (not perfect protection) of the key embedded in a packaged app.
   *
   */
  @DesignerProperty(editorType = PropertyTypeConstants.PROPERTY_TYPE_STRING)
  @SimpleProperty(category = PropertyCategory.BEHAVIOR,
      description = "A ChatGPT API Key. If provided, it will be used instead of " +
         "the embedded APIKEY in the ChatBot proxy server")
  @JsProperty(name = "ApiKey")
  public void ApiKey(String apikey) {
    this.apiKey = apikey;
  }

  @SimpleProperty
  @JsProperty(name = "ApiKey")
  public String ApiKey() {
    return this.apiKey;
  }

  /**
   * Set the name of the provider to use. See https://appinv.us/chatbot for
   * the current list of supported providers.
   */
  @SimpleProperty(category = PropertyCategory.BEHAVIOR,
    description = "Set the name of the provider to use. " +
    "See https://appinv.us/chatbot for the current list of supported " +
    "providers.",
    userVisible = true)
  @JsProperty(name = "Provider")
  public String Provider() {
    return provider;
  }

  @DesignerProperty(editorType = PropertyTypeConstants.PROPERTY_TYPE_CHATBOT_PROVIDER,
    defaultValue = "chatgpt")
  @SimpleProperty(description = "Set the name of the provider to use. " +
    "See https://appinv.us/chatbot for the current list of supported " +
    "providers.",
    userVisible = true)
  @JsProperty(name = "Provider")
  public void Provider(@Provider String provider) {
    this.provider = provider;
  }

  /**
   * Set the name of the model to use. See https://appinv.us/chatbot for
   * the current list of supported models.
   */
  @SimpleProperty(category = PropertyCategory.BEHAVIOR,
    description = "Set the name of the model to use. " +
    "See https://appinv.us/chatbot for the current list of supported " +
    "models. Leaving this blank will result in the default model set by " +
    "the provider being used",
    userVisible = true)
  @JsProperty(name = "Model")
  public String Model() {
    return model;
  }

  @DesignerProperty(editorType = PropertyTypeConstants.PROPERTY_TYPE_CHATBOT_MODEL,
    defaultValue = "")
  @SimpleProperty(description = "Set the name of the model to use. " +
    "See https://appinv.us/chatbot for the current list of supported " +
    "models. Leaving this blank will result in the default model set by " +
    "the provider being used",
    userVisible = true)
  @JsProperty(name = "Model")
  public void Model(@ProviderModel String model) {
    this.model = model;
  }

  /**
   * The ErrorOccurred event will be run when an error occurs during
   * processing, such as if your you are over usage quota, or some
   * other error signaled by ChatGPT or PaLM. See
   * https://appinv.us/chatbot for current information.
   *
   * @param responseCode the HTTP status code returned by the server
   * @param responseText a description of the error
   */

  @SimpleEvent
  public void ErrorOccurred(final int responseCode, final String responseText) {
    form.runOnUiThread(new Runnable() {
        @Override
        public void run() {
          if (!EventDispatcher.dispatchEvent(ChatBot.this, "ErrorOccurred", responseCode, responseText)) {
            form.dispatchErrorOccurredEvent(ChatBot.this, "ErrorOccurred",
              ErrorMessages.ERROR_CHATBOT_ERROR, responseCode, responseText);
          }
        }
      });
  }

  private Bitmap loadImage(Object source) throws IOException {
    Bitmap bitmap = null;
    Log.d(LOG_TAG, "loadImage source = " + source);
    if (source instanceof Canvas) {
      bitmap = ((Canvas) source).getBitmap();
    } else if (source instanceof Image) {
      bitmap = ((BitmapDrawable) ((Image) source).getView().getBackground()).getBitmap();
    } else {
      String sourceStr = source.toString();
      bitmap = MediaUtil.getBitmapDrawable(form, sourceStr).getBitmap();
    }
    if (bitmap != null) {
      if (bitmap.getWidth() == size && bitmap.getHeight() == size) {
        return bitmap;
      } else {
        bitmap = Bitmap.createScaledBitmap(bitmap, size, size, false);
      }
    }
    return bitmap;
  }
}

