<?php
/**
 * Copyright 2007 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
# Generated by the protocol buffer compiler. DO NOT EDIT!
# source: google/appengine/datastore/document.proto

namespace dummy {
  if (!defined('GOOGLE_APPENGINE_CLASSLOADER')) {
    require_once 'google/appengine/runtime/proto/ProtocolMessage.php';
  }
}
namespace storage_onestore_v3\FieldValue {
  class ContentType {
    const TEXT = 0;
    const HTML = 1;
    const ATOM = 2;
    const DATE = 3;
    const NUMBER = 4;
    const GEO = 5;
    const UNTOKENIZED_PREFIX = 6;
    const TOKENIZED_PREFIX = 7;
    const VECTOR = 8;
  }
}
namespace storage_onestore_v3\FieldValue {
  class Geo extends \google\net\ProtocolMessage {
    public function getLat() {
      if (!isset($this->lat)) {
        return 0.0;
      }
      return $this->lat;
    }
    public function setLat($val) {
      $this->lat = $val;
      return $this;
    }
    public function clearLat() {
      unset($this->lat);
      return $this;
    }
    public function hasLat() {
      return isset($this->lat);
    }
    public function getLng() {
      if (!isset($this->lng)) {
        return 0.0;
      }
      return $this->lng;
    }
    public function setLng($val) {
      $this->lng = $val;
      return $this;
    }
    public function clearLng() {
      unset($this->lng);
      return $this;
    }
    public function hasLng() {
      return isset($this->lng);
    }
    public function clear() {
      $this->clearLat();
      $this->clearLng();
    }
    public function byteSizePartial() {
      $res = 0;
      if (isset($this->lat)) {
        $res += 9;
      }
      if (isset($this->lng)) {
        $res += 9;
      }
      return $res;
    }
    public function outputPartial($out) {
      if (isset($this->lat)) {
        $out->putVarInt32(41);
        $out->putDouble($this->lat);
      }
      if (isset($this->lng)) {
        $out->putVarInt32(49);
        $out->putDouble($this->lng);
      }
    }
    public function tryMerge($d) {
      while($d->avail() > 0) {
        $tt = $d->getVarInt32();
        switch ($tt) {
          case 36: return;
          case 41:
            $this->setLat($d->getDouble());
            break;
          case 49:
            $this->setLng($d->getDouble());
            break;
          case 0:
            throw new \google\net\ProtocolBufferDecodeError();
            break;
          default:
            $d->skipData($tt);
        }
      };
    }
    public function checkInitialized() {
      if (!isset($this->lat)) return 'lat';
      if (!isset($this->lng)) return 'lng';
      return null;
    }
    public function mergeFrom($x) {
      if ($x === $this) { throw new \IllegalArgumentException('Cannot copy message to itself'); }
      if ($x->hasLat()) {
        $this->setLat($x->getLat());
      }
      if ($x->hasLng()) {
        $this->setLng($x->getLng());
      }
    }
    public function equals($x) {
      if ($x === $this) { return true; }
      if (isset($this->lat) !== isset($x->lat)) return false;
      if (isset($this->lat) && $this->lat !== $x->lat) return false;
      if (isset($this->lng) !== isset($x->lng)) return false;
      if (isset($this->lng) && $this->lng !== $x->lng) return false;
      return true;
    }
    public function shortDebugString($prefix = "") {
      $res = '';
      if (isset($this->lat)) {
        $res .= $prefix . "lat: " . $this->debugFormatDouble($this->lat) . "\n";
      }
      if (isset($this->lng)) {
        $res .= $prefix . "lng: " . $this->debugFormatDouble($this->lng) . "\n";
      }
      return $res;
    }
  }
}
namespace storage_onestore_v3 {
  class FieldValue extends \google\net\ProtocolMessage {
    private $vector_value = array();
    public function getType() {
      if (!isset($this->type)) {
        return 0;
      }
      return $this->type;
    }
    public function setType($val) {
      $this->type = $val;
      return $this;
    }
    public function clearType() {
      unset($this->type);
      return $this;
    }
    public function hasType() {
      return isset($this->type);
    }
    public function getLanguage() {
      if (!isset($this->language)) {
        return "en";
      }
      return $this->language;
    }
    public function setLanguage($val) {
      $this->language = $val;
      return $this;
    }
    public function clearLanguage() {
      unset($this->language);
      return $this;
    }
    public function hasLanguage() {
      return isset($this->language);
    }
    public function getStringValue() {
      if (!isset($this->string_value)) {
        return '';
      }
      return $this->string_value;
    }
    public function setStringValue($val) {
      $this->string_value = $val;
      return $this;
    }
    public function clearStringValue() {
      unset($this->string_value);
      return $this;
    }
    public function hasStringValue() {
      return isset($this->string_value);
    }
    public function getGeo() {
      if (!isset($this->geo)) {
        return new \storage_onestore_v3\FieldValue\Geo();
      }
      return $this->geo;
    }
    public function mutableGeo() {
      if (!isset($this->geo)) {
        $res = new \storage_onestore_v3\FieldValue\Geo();
        $this->geo = $res;
        return $res;
      }
      return $this->geo;
    }
    public function clearGeo() {
      if (isset($this->geo)) {
        unset($this->geo);
      }
    }
    public function hasGeo() {
      return isset($this->geo);
    }
    public function getVectorValueSize() {
      return sizeof($this->vector_value);
    }
    public function getVectorValueList() {
      return $this->vector_value;
    }
    public function getVectorValue($idx) {
      return $this->vector_value[$idx];
    }
    public function setVectorValue($idx, $val) {
      $this->vector_value[$idx] = $val;
      return $this;
    }
    public function addVectorValue($val) {
      $this->vector_value[] = $val;
      return $this;
    }
    public function clearVectorValue() {
      $this->vector_value = array();
    }
    public function clear() {
      $this->clearType();
      $this->clearLanguage();
      $this->clearStringValue();
      $this->clearGeo();
      $this->clearVectorValue();
    }
    public function byteSizePartial() {
      $res = 0;
      if (isset($this->type)) {
        $res += 1;
        $res += $this->lengthVarInt64($this->type);
      }
      if (isset($this->language)) {
        $res += 1;
        $res += $this->lengthString(strlen($this->language));
      }
      if (isset($this->string_value)) {
        $res += 1;
        $res += $this->lengthString(strlen($this->string_value));
      }
      if (isset($this->geo)) {
        $res += 2;
        $res += $this->geo->byteSizePartial();
      }
      $this->checkProtoArray($this->vector_value);
      $res += 9 * sizeof($this->vector_value);
      return $res;
    }
    public function outputPartial($out) {
      if (isset($this->type)) {
        $out->putVarInt32(8);
        $out->putVarInt32($this->type);
      }
      if (isset($this->language)) {
        $out->putVarInt32(18);
        $out->putPrefixedString($this->language);
      }
      if (isset($this->string_value)) {
        $out->putVarInt32(26);
        $out->putPrefixedString($this->string_value);
      }
      if (isset($this->geo)) {
        $out->putVarInt32(35);
        $this->geo->outputPartial($out);
        $out->putVarInt32(36);
      }
      $this->checkProtoArray($this->vector_value);
      foreach ($this->vector_value as $value) {
        $out->putVarInt32(57);
        $out->putDouble($value);
      }
    }
    public function tryMerge($d) {
      while($d->avail() > 0) {
        $tt = $d->getVarInt32();
        switch ($tt) {
          case 8:
            $this->setType($d->getVarInt32());
            break;
          case 18:
            $length = $d->getVarInt32();
            $this->setLanguage(substr($d->buffer(), $d->pos(), $length));
            $d->skip($length);
            break;
          case 26:
            $length = $d->getVarInt32();
            $this->setStringValue(substr($d->buffer(), $d->pos(), $length));
            $d->skip($length);
            break;
          case 35:
            $this->mutableGeo()->tryMerge($d);
            break;
          case 57:
            $this->addVectorValue($d->getDouble());
            break;
          case 0:
            throw new \google\net\ProtocolBufferDecodeError();
            break;
          default:
            $d->skipData($tt);
        }
      };
    }
    public function checkInitialized() {
      if (isset($this->geo) && (!$this->geo->isInitialized())) return 'geo';
      return null;
    }
    public function mergeFrom($x) {
      if ($x === $this) { throw new \IllegalArgumentException('Cannot copy message to itself'); }
      if ($x->hasType()) {
        $this->setType($x->getType());
      }
      if ($x->hasLanguage()) {
        $this->setLanguage($x->getLanguage());
      }
      if ($x->hasStringValue()) {
        $this->setStringValue($x->getStringValue());
      }
      if ($x->hasGeo()) {
        $this->mutableGeo()->mergeFrom($x->getGeo());
      }
      foreach ($x->getVectorValueList() as $v) {
        $this->addVectorValue($v);
      }
    }
    public function equals($x) {
      if ($x === $this) { return true; }
      if (isset($this->type) !== isset($x->type)) return false;
      if (isset($this->type) && $this->type !== $x->type) return false;
      if (isset($this->language) !== isset($x->language)) return false;
      if (isset($this->language) && $this->language !== $x->language) return false;
      if (isset($this->string_value) !== isset($x->string_value)) return false;
      if (isset($this->string_value) && $this->string_value !== $x->string_value) return false;
      if (isset($this->geo) !== isset($x->geo)) return false;
      if (isset($this->geo) && !$this->geo->equals($x->geo)) return false;
      if (sizeof($this->vector_value) !== sizeof($x->vector_value)) return false;
      foreach (array_map(null, $this->vector_value, $x->vector_value) as $v) {
        if ($v[0] !== $v[1]) return false;
      }
      return true;
    }
    public function shortDebugString($prefix = "") {
      $res = '';
      if (isset($this->type)) {
        $res .= $prefix . "type: " . ($this->type) . "\n";
      }
      if (isset($this->language)) {
        $res .= $prefix . "language: " . $this->debugFormatString($this->language) . "\n";
      }
      if (isset($this->string_value)) {
        $res .= $prefix . "string_value: " . $this->debugFormatString($this->string_value) . "\n";
      }
      if (isset($this->geo)) {
        $res .= $prefix . "Geo {\n" . $this->geo->shortDebugString($prefix . "  ") . $prefix . "}\n";
      }
      foreach ($this->vector_value as $value) {
        $res .= $prefix . "vector_value: " . $this->debugFormatDouble($value) . "\n";
      }
      return $res;
    }
  }
}
namespace storage_onestore_v3 {
  class Field extends \google\net\ProtocolMessage {
    public function getName() {
      if (!isset($this->name)) {
        return '';
      }
      return $this->name;
    }
    public function setName($val) {
      $this->name = $val;
      return $this;
    }
    public function clearName() {
      unset($this->name);
      return $this;
    }
    public function hasName() {
      return isset($this->name);
    }
    public function getValue() {
      if (!isset($this->value)) {
        return new \storage_onestore_v3\FieldValue();
      }
      return $this->value;
    }
    public function mutableValue() {
      if (!isset($this->value)) {
        $res = new \storage_onestore_v3\FieldValue();
        $this->value = $res;
        return $res;
      }
      return $this->value;
    }
    public function clearValue() {
      if (isset($this->value)) {
        unset($this->value);
      }
    }
    public function hasValue() {
      return isset($this->value);
    }
    public function clear() {
      $this->clearName();
      $this->clearValue();
    }
    public function byteSizePartial() {
      $res = 0;
      if (isset($this->name)) {
        $res += 1;
        $res += $this->lengthString(strlen($this->name));
      }
      if (isset($this->value)) {
        $res += 1;
        $res += $this->lengthString($this->value->byteSizePartial());
      }
      return $res;
    }
    public function outputPartial($out) {
      if (isset($this->name)) {
        $out->putVarInt32(10);
        $out->putPrefixedString($this->name);
      }
      if (isset($this->value)) {
        $out->putVarInt32(18);
        $out->putVarInt32($this->value->byteSizePartial());
        $this->value->outputPartial($out);
      }
    }
    public function tryMerge($d) {
      while($d->avail() > 0) {
        $tt = $d->getVarInt32();
        switch ($tt) {
          case 10:
            $length = $d->getVarInt32();
            $this->setName(substr($d->buffer(), $d->pos(), $length));
            $d->skip($length);
            break;
          case 18:
            $length = $d->getVarInt32();
            $tmp = new \google\net\Decoder($d->buffer(), $d->pos(), $d->pos() + $length);
            $d->skip($length);
            $this->mutableValue()->tryMerge($tmp);
            break;
          case 0:
            throw new \google\net\ProtocolBufferDecodeError();
            break;
          default:
            $d->skipData($tt);
        }
      };
    }
    public function checkInitialized() {
      if (!isset($this->name)) return 'name';
      if ((!isset($this->value)) || (!$this->value->isInitialized())) return 'value';
      return null;
    }
    public function mergeFrom($x) {
      if ($x === $this) { throw new \IllegalArgumentException('Cannot copy message to itself'); }
      if ($x->hasName()) {
        $this->setName($x->getName());
      }
      if ($x->hasValue()) {
        $this->mutableValue()->mergeFrom($x->getValue());
      }
    }
    public function equals($x) {
      if ($x === $this) { return true; }
      if (isset($this->name) !== isset($x->name)) return false;
      if (isset($this->name) && $this->name !== $x->name) return false;
      if (isset($this->value) !== isset($x->value)) return false;
      if (isset($this->value) && !$this->value->equals($x->value)) return false;
      return true;
    }
    public function shortDebugString($prefix = "") {
      $res = '';
      if (isset($this->name)) {
        $res .= $prefix . "name: " . $this->debugFormatString($this->name) . "\n";
      }
      if (isset($this->value)) {
        $res .= $prefix . "value <\n" . $this->value->shortDebugString($prefix . "  ") . $prefix . ">\n";
      }
      return $res;
    }
  }
}
namespace storage_onestore_v3 {
  class FieldTypes extends \google\net\ProtocolMessage {
    private $type = array();
    public function getName() {
      if (!isset($this->name)) {
        return '';
      }
      return $this->name;
    }
    public function setName($val) {
      $this->name = $val;
      return $this;
    }
    public function clearName() {
      unset($this->name);
      return $this;
    }
    public function hasName() {
      return isset($this->name);
    }
    public function getTypeSize() {
      return sizeof($this->type);
    }
    public function getTypeList() {
      return $this->type;
    }
    public function getType($idx) {
      return $this->type[$idx];
    }
    public function setType($idx, $val) {
      $this->type[$idx] = $val;
      return $this;
    }
    public function addType($val) {
      $this->type[] = $val;
      return $this;
    }
    public function clearType() {
      $this->type = array();
    }
    public function clear() {
      $this->clearName();
      $this->clearType();
    }
    public function byteSizePartial() {
      $res = 0;
      if (isset($this->name)) {
        $res += 1;
        $res += $this->lengthString(strlen($this->name));
      }
      $this->checkProtoArray($this->type);
      $res += 1 * sizeof($this->type);
      foreach ($this->type as $value) {
        $res += $this->lengthVarInt64($value);
      }
      return $res;
    }
    public function outputPartial($out) {
      if (isset($this->name)) {
        $out->putVarInt32(10);
        $out->putPrefixedString($this->name);
      }
      $this->checkProtoArray($this->type);
      foreach ($this->type as $value) {
        $out->putVarInt32(16);
        $out->putVarInt32($value);
      }
    }
    public function tryMerge($d) {
      while($d->avail() > 0) {
        $tt = $d->getVarInt32();
        switch ($tt) {
          case 10:
            $length = $d->getVarInt32();
            $this->setName(substr($d->buffer(), $d->pos(), $length));
            $d->skip($length);
            break;
          case 16:
            $this->addType($d->getVarInt32());
            break;
          case 0:
            throw new \google\net\ProtocolBufferDecodeError();
            break;
          default:
            $d->skipData($tt);
        }
      };
    }
    public function checkInitialized() {
      if (!isset($this->name)) return 'name';
      return null;
    }
    public function mergeFrom($x) {
      if ($x === $this) { throw new \IllegalArgumentException('Cannot copy message to itself'); }
      if ($x->hasName()) {
        $this->setName($x->getName());
      }
      foreach ($x->getTypeList() as $v) {
        $this->addType($v);
      }
    }
    public function equals($x) {
      if ($x === $this) { return true; }
      if (isset($this->name) !== isset($x->name)) return false;
      if (isset($this->name) && $this->name !== $x->name) return false;
      if (sizeof($this->type) !== sizeof($x->type)) return false;
      foreach (array_map(null, $this->type, $x->type) as $v) {
        if ($v[0] !== $v[1]) return false;
      }
      return true;
    }
    public function shortDebugString($prefix = "") {
      $res = '';
      if (isset($this->name)) {
        $res .= $prefix . "name: " . $this->debugFormatString($this->name) . "\n";
      }
      foreach ($this->type as $value) {
        $res .= $prefix . "type: " . ($value) . "\n";
      }
      return $res;
    }
  }
}
namespace storage_onestore_v3 {
  class IndexShardSettings extends \google\net\ProtocolMessage {
    private $prev_num_shards = array();
    private $prev_num_shards_search_false = array();
    public function getPrevNumShardsSize() {
      return sizeof($this->prev_num_shards);
    }
    public function getPrevNumShardsList() {
      return $this->prev_num_shards;
    }
    public function getPrevNumShards($idx) {
      return $this->prev_num_shards[$idx];
    }
    public function setPrevNumShards($idx, $val) {
      $this->prev_num_shards[$idx] = $val;
      return $this;
    }
    public function addPrevNumShards($val) {
      $this->prev_num_shards[] = $val;
      return $this;
    }
    public function clearPrevNumShards() {
      $this->prev_num_shards = array();
    }
    public function getNumShards() {
      if (!isset($this->num_shards)) {
        return 1;
      }
      return $this->num_shards;
    }
    public function setNumShards($val) {
      $this->num_shards = $val;
      return $this;
    }
    public function clearNumShards() {
      unset($this->num_shards);
      return $this;
    }
    public function hasNumShards() {
      return isset($this->num_shards);
    }
    public function getPrevNumShardsSearchFalseSize() {
      return sizeof($this->prev_num_shards_search_false);
    }
    public function getPrevNumShardsSearchFalseList() {
      return $this->prev_num_shards_search_false;
    }
    public function getPrevNumShardsSearchFalse($idx) {
      return $this->prev_num_shards_search_false[$idx];
    }
    public function setPrevNumShardsSearchFalse($idx, $val) {
      $this->prev_num_shards_search_false[$idx] = $val;
      return $this;
    }
    public function addPrevNumShardsSearchFalse($val) {
      $this->prev_num_shards_search_false[] = $val;
      return $this;
    }
    public function clearPrevNumShardsSearchFalse() {
      $this->prev_num_shards_search_false = array();
    }
    public function getLocalReplica() {
      if (!isset($this->local_replica)) {
        return '';
      }
      return $this->local_replica;
    }
    public function setLocalReplica($val) {
      $this->local_replica = $val;
      return $this;
    }
    public function clearLocalReplica() {
      unset($this->local_replica);
      return $this;
    }
    public function hasLocalReplica() {
      return isset($this->local_replica);
    }
    public function clear() {
      $this->clearPrevNumShards();
      $this->clearNumShards();
      $this->clearPrevNumShardsSearchFalse();
      $this->clearLocalReplica();
    }
    public function byteSizePartial() {
      $res = 0;
      $this->checkProtoArray($this->prev_num_shards);
      $res += 1 * sizeof($this->prev_num_shards);
      foreach ($this->prev_num_shards as $value) {
        $res += $this->lengthVarInt64($value);
      }
      if (isset($this->num_shards)) {
        $res += 1;
        $res += $this->lengthVarInt64($this->num_shards);
      }
      $this->checkProtoArray($this->prev_num_shards_search_false);
      $res += 1 * sizeof($this->prev_num_shards_search_false);
      foreach ($this->prev_num_shards_search_false as $value) {
        $res += $this->lengthVarInt64($value);
      }
      if (isset($this->local_replica)) {
        $res += 1;
        $res += $this->lengthString(strlen($this->local_replica));
      }
      return $res;
    }
    public function outputPartial($out) {
      $this->checkProtoArray($this->prev_num_shards);
      foreach ($this->prev_num_shards as $value) {
        $out->putVarInt32(8);
        $out->putVarInt32($value);
      }
      if (isset($this->num_shards)) {
        $out->putVarInt32(16);
        $out->putVarInt32($this->num_shards);
      }
      $this->checkProtoArray($this->prev_num_shards_search_false);
      foreach ($this->prev_num_shards_search_false as $value) {
        $out->putVarInt32(24);
        $out->putVarInt32($value);
      }
      if (isset($this->local_replica)) {
        $out->putVarInt32(34);
        $out->putPrefixedString($this->local_replica);
      }
    }
    public function tryMerge($d) {
      while($d->avail() > 0) {
        $tt = $d->getVarInt32();
        switch ($tt) {
          case 8:
            $this->addPrevNumShards($d->getVarInt32());
            break;
          case 16:
            $this->setNumShards($d->getVarInt32());
            break;
          case 24:
            $this->addPrevNumShardsSearchFalse($d->getVarInt32());
            break;
          case 34:
            $length = $d->getVarInt32();
            $this->setLocalReplica(substr($d->buffer(), $d->pos(), $length));
            $d->skip($length);
            break;
          case 0:
            throw new \google\net\ProtocolBufferDecodeError();
            break;
          default:
            $d->skipData($tt);
        }
      };
    }
    public function checkInitialized() {
      if (!isset($this->num_shards)) return 'num_shards';
      return null;
    }
    public function mergeFrom($x) {
      if ($x === $this) { throw new \IllegalArgumentException('Cannot copy message to itself'); }
      foreach ($x->getPrevNumShardsList() as $v) {
        $this->addPrevNumShards($v);
      }
      if ($x->hasNumShards()) {
        $this->setNumShards($x->getNumShards());
      }
      foreach ($x->getPrevNumShardsSearchFalseList() as $v) {
        $this->addPrevNumShardsSearchFalse($v);
      }
      if ($x->hasLocalReplica()) {
        $this->setLocalReplica($x->getLocalReplica());
      }
    }
    public function equals($x) {
      if ($x === $this) { return true; }
      if (sizeof($this->prev_num_shards) !== sizeof($x->prev_num_shards)) return false;
      foreach (array_map(null, $this->prev_num_shards, $x->prev_num_shards) as $v) {
        if (!$this->integerEquals($v[0], $v[1])) return false;
      }
      if (isset($this->num_shards) !== isset($x->num_shards)) return false;
      if (isset($this->num_shards) && !$this->integerEquals($this->num_shards, $x->num_shards)) return false;
      if (sizeof($this->prev_num_shards_search_false) !== sizeof($x->prev_num_shards_search_false)) return false;
      foreach (array_map(null, $this->prev_num_shards_search_false, $x->prev_num_shards_search_false) as $v) {
        if (!$this->integerEquals($v[0], $v[1])) return false;
      }
      if (isset($this->local_replica) !== isset($x->local_replica)) return false;
      if (isset($this->local_replica) && $this->local_replica !== $x->local_replica) return false;
      return true;
    }
    public function shortDebugString($prefix = "") {
      $res = '';
      foreach ($this->prev_num_shards as $value) {
        $res .= $prefix . "prev_num_shards: " . $this->debugFormatInt32($value) . "\n";
      }
      if (isset($this->num_shards)) {
        $res .= $prefix . "num_shards: " . $this->debugFormatInt32($this->num_shards) . "\n";
      }
      foreach ($this->prev_num_shards_search_false as $value) {
        $res .= $prefix . "prev_num_shards_search_false: " . $this->debugFormatInt32($value) . "\n";
      }
      if (isset($this->local_replica)) {
        $res .= $prefix . "local_replica: " . $this->debugFormatString($this->local_replica) . "\n";
      }
      return $res;
    }
  }
}
namespace storage_onestore_v3\IndexMetadata {
  class IndexState {
    const ACTIVE = 0;
    const SOFT_DELETED = 1;
    const PURGING = 2;
  }
}
namespace storage_onestore_v3\IndexMetadata {
  class DeletionStatus extends \google\net\ProtocolMessage {
    public function getStartedTime() {
      if (!isset($this->started_time)) {
        return "0";
      }
      return $this->started_time;
    }
    public function setStartedTime($val) {
      if (is_double($val)) {
        $this->started_time = sprintf('%0.0F', $val);
      } else {
        $this->started_time = $val;
      }
      return $this;
    }
    public function clearStartedTime() {
      unset($this->started_time);
      return $this;
    }
    public function hasStartedTime() {
      return isset($this->started_time);
    }
    public function getCompletedTime() {
      if (!isset($this->completed_time)) {
        return "0";
      }
      return $this->completed_time;
    }
    public function setCompletedTime($val) {
      if (is_double($val)) {
        $this->completed_time = sprintf('%0.0F', $val);
      } else {
        $this->completed_time = $val;
      }
      return $this;
    }
    public function clearCompletedTime() {
      unset($this->completed_time);
      return $this;
    }
    public function hasCompletedTime() {
      return isset($this->completed_time);
    }
    public function clear() {
      $this->clearStartedTime();
      $this->clearCompletedTime();
    }
    public function byteSizePartial() {
      $res = 0;
      if (isset($this->started_time)) {
        $res += 1;
        $res += $this->lengthVarInt64($this->started_time);
      }
      if (isset($this->completed_time)) {
        $res += 1;
        $res += $this->lengthVarInt64($this->completed_time);
      }
      return $res;
    }
    public function outputPartial($out) {
      if (isset($this->started_time)) {
        $out->putVarInt32(24);
        $out->putVarInt64($this->started_time);
      }
      if (isset($this->completed_time)) {
        $out->putVarInt32(32);
        $out->putVarInt64($this->completed_time);
      }
    }
    public function tryMerge($d) {
      while($d->avail() > 0) {
        $tt = $d->getVarInt32();
        switch ($tt) {
          case 24:
            $this->setStartedTime($d->getVarInt64());
            break;
          case 32:
            $this->setCompletedTime($d->getVarInt64());
            break;
          case 0:
            throw new \google\net\ProtocolBufferDecodeError();
            break;
          default:
            $d->skipData($tt);
        }
      };
    }
    public function checkInitialized() {
      return null;
    }
    public function mergeFrom($x) {
      if ($x === $this) { throw new \IllegalArgumentException('Cannot copy message to itself'); }
      if ($x->hasStartedTime()) {
        $this->setStartedTime($x->getStartedTime());
      }
      if ($x->hasCompletedTime()) {
        $this->setCompletedTime($x->getCompletedTime());
      }
    }
    public function equals($x) {
      if ($x === $this) { return true; }
      if (isset($this->started_time) !== isset($x->started_time)) return false;
      if (isset($this->started_time) && !$this->integerEquals($this->started_time, $x->started_time)) return false;
      if (isset($this->completed_time) !== isset($x->completed_time)) return false;
      if (isset($this->completed_time) && !$this->integerEquals($this->completed_time, $x->completed_time)) return false;
      return true;
    }
    public function shortDebugString($prefix = "") {
      $res = '';
      if (isset($this->started_time)) {
        $res .= $prefix . "started_time: " . $this->debugFormatInt64($this->started_time) . "\n";
      }
      if (isset($this->completed_time)) {
        $res .= $prefix . "completed_time: " . $this->debugFormatInt64($this->completed_time) . "\n";
      }
      return $res;
    }
  }
}
namespace storage_onestore_v3\IndexMetadata {
  class IndexDeletionDetails extends \google\net\ProtocolMessage {
    public function getReplicaName() {
      if (!isset($this->replica_name)) {
        return '';
      }
      return $this->replica_name;
    }
    public function setReplicaName($val) {
      $this->replica_name = $val;
      return $this;
    }
    public function clearReplicaName() {
      unset($this->replica_name);
      return $this;
    }
    public function hasReplicaName() {
      return isset($this->replica_name);
    }
    public function getPrecheck() {
      if (!isset($this->precheck)) {
        return new \storage_onestore_v3\IndexMetadata\DeletionStatus();
      }
      return $this->precheck;
    }
    public function mutablePrecheck() {
      if (!isset($this->precheck)) {
        $res = new \storage_onestore_v3\IndexMetadata\DeletionStatus();
        $this->precheck = $res;
        return $res;
      }
      return $this->precheck;
    }
    public function clearPrecheck() {
      if (isset($this->precheck)) {
        unset($this->precheck);
      }
    }
    public function hasPrecheck() {
      return isset($this->precheck);
    }
    public function getStBti() {
      if (!isset($this->st_bti)) {
        return new \storage_onestore_v3\IndexMetadata\DeletionStatus();
      }
      return $this->st_bti;
    }
    public function mutableStBti() {
      if (!isset($this->st_bti)) {
        $res = new \storage_onestore_v3\IndexMetadata\DeletionStatus();
        $this->st_bti = $res;
        return $res;
      }
      return $this->st_bti;
    }
    public function clearStBti() {
      if (isset($this->st_bti)) {
        unset($this->st_bti);
      }
    }
    public function hasStBti() {
      return isset($this->st_bti);
    }
    public function getMsDocs() {
      if (!isset($this->ms_docs)) {
        return new \storage_onestore_v3\IndexMetadata\DeletionStatus();
      }
      return $this->ms_docs;
    }
    public function mutableMsDocs() {
      if (!isset($this->ms_docs)) {
        $res = new \storage_onestore_v3\IndexMetadata\DeletionStatus();
        $this->ms_docs = $res;
        return $res;
      }
      return $this->ms_docs;
    }
    public function clearMsDocs() {
      if (isset($this->ms_docs)) {
        unset($this->ms_docs);
      }
    }
    public function hasMsDocs() {
      return isset($this->ms_docs);
    }
    public function clear() {
      $this->clearReplicaName();
      $this->clearPrecheck();
      $this->clearStBti();
      $this->clearMsDocs();
    }
    public function byteSizePartial() {
      $res = 0;
      if (isset($this->replica_name)) {
        $res += 1;
        $res += $this->lengthString(strlen($this->replica_name));
      }
      if (isset($this->precheck)) {
        $res += 1;
        $res += $this->lengthString($this->precheck->byteSizePartial());
      }
      if (isset($this->st_bti)) {
        $res += 1;
        $res += $this->lengthString($this->st_bti->byteSizePartial());
      }
      if (isset($this->ms_docs)) {
        $res += 1;
        $res += $this->lengthString($this->ms_docs->byteSizePartial());
      }
      return $res;
    }
    public function outputPartial($out) {
      if (isset($this->replica_name)) {
        $out->putVarInt32(10);
        $out->putPrefixedString($this->replica_name);
      }
      if (isset($this->precheck)) {
        $out->putVarInt32(18);
        $out->putVarInt32($this->precheck->byteSizePartial());
        $this->precheck->outputPartial($out);
      }
      if (isset($this->st_bti)) {
        $out->putVarInt32(26);
        $out->putVarInt32($this->st_bti->byteSizePartial());
        $this->st_bti->outputPartial($out);
      }
      if (isset($this->ms_docs)) {
        $out->putVarInt32(34);
        $out->putVarInt32($this->ms_docs->byteSizePartial());
        $this->ms_docs->outputPartial($out);
      }
    }
    public function tryMerge($d) {
      while($d->avail() > 0) {
        $tt = $d->getVarInt32();
        switch ($tt) {
          case 10:
            $length = $d->getVarInt32();
            $this->setReplicaName(substr($d->buffer(), $d->pos(), $length));
            $d->skip($length);
            break;
          case 18:
            $length = $d->getVarInt32();
            $tmp = new \google\net\Decoder($d->buffer(), $d->pos(), $d->pos() + $length);
            $d->skip($length);
            $this->mutablePrecheck()->tryMerge($tmp);
            break;
          case 26:
            $length = $d->getVarInt32();
            $tmp = new \google\net\Decoder($d->buffer(), $d->pos(), $d->pos() + $length);
            $d->skip($length);
            $this->mutableStBti()->tryMerge($tmp);
            break;
          case 34:
            $length = $d->getVarInt32();
            $tmp = new \google\net\Decoder($d->buffer(), $d->pos(), $d->pos() + $length);
            $d->skip($length);
            $this->mutableMsDocs()->tryMerge($tmp);
            break;
          case 0:
            throw new \google\net\ProtocolBufferDecodeError();
            break;
          default:
            $d->skipData($tt);
        }
      };
    }
    public function checkInitialized() {
      if (!isset($this->replica_name)) return 'replica_name';
      if (isset($this->precheck) && (!$this->precheck->isInitialized())) return 'precheck';
      if (isset($this->st_bti) && (!$this->st_bti->isInitialized())) return 'st_bti';
      if (isset($this->ms_docs) && (!$this->ms_docs->isInitialized())) return 'ms_docs';
      return null;
    }
    public function mergeFrom($x) {
      if ($x === $this) { throw new \IllegalArgumentException('Cannot copy message to itself'); }
      if ($x->hasReplicaName()) {
        $this->setReplicaName($x->getReplicaName());
      }
      if ($x->hasPrecheck()) {
        $this->mutablePrecheck()->mergeFrom($x->getPrecheck());
      }
      if ($x->hasStBti()) {
        $this->mutableStBti()->mergeFrom($x->getStBti());
      }
      if ($x->hasMsDocs()) {
        $this->mutableMsDocs()->mergeFrom($x->getMsDocs());
      }
    }
    public function equals($x) {
      if ($x === $this) { return true; }
      if (isset($this->replica_name) !== isset($x->replica_name)) return false;
      if (isset($this->replica_name) && $this->replica_name !== $x->replica_name) return false;
      if (isset($this->precheck) !== isset($x->precheck)) return false;
      if (isset($this->precheck) && !$this->precheck->equals($x->precheck)) return false;
      if (isset($this->st_bti) !== isset($x->st_bti)) return false;
      if (isset($this->st_bti) && !$this->st_bti->equals($x->st_bti)) return false;
      if (isset($this->ms_docs) !== isset($x->ms_docs)) return false;
      if (isset($this->ms_docs) && !$this->ms_docs->equals($x->ms_docs)) return false;
      return true;
    }
    public function shortDebugString($prefix = "") {
      $res = '';
      if (isset($this->replica_name)) {
        $res .= $prefix . "replica_name: " . $this->debugFormatString($this->replica_name) . "\n";
      }
      if (isset($this->precheck)) {
        $res .= $prefix . "precheck <\n" . $this->precheck->shortDebugString($prefix . "  ") . $prefix . ">\n";
      }
      if (isset($this->st_bti)) {
        $res .= $prefix . "st_bti <\n" . $this->st_bti->shortDebugString($prefix . "  ") . $prefix . ">\n";
      }
      if (isset($this->ms_docs)) {
        $res .= $prefix . "ms_docs <\n" . $this->ms_docs->shortDebugString($prefix . "  ") . $prefix . ">\n";
      }
      return $res;
    }
  }
}
namespace storage_onestore_v3 {
  class IndexMetadata extends \google\net\ProtocolMessage {
    private $replica_deletion = array();
    public function getIsOverFieldNumberThreshold() {
      if (!isset($this->is_over_field_number_threshold)) {
        return false;
      }
      return $this->is_over_field_number_threshold;
    }
    public function setIsOverFieldNumberThreshold($val) {
      $this->is_over_field_number_threshold = $val;
      return $this;
    }
    public function clearIsOverFieldNumberThreshold() {
      unset($this->is_over_field_number_threshold);
      return $this;
    }
    public function hasIsOverFieldNumberThreshold() {
      return isset($this->is_over_field_number_threshold);
    }
    public function getIndexShardSettings() {
      if (!isset($this->index_shard_settings)) {
        return new \storage_onestore_v3\IndexShardSettings();
      }
      return $this->index_shard_settings;
    }
    public function mutableIndexShardSettings() {
      if (!isset($this->index_shard_settings)) {
        $res = new \storage_onestore_v3\IndexShardSettings();
        $this->index_shard_settings = $res;
        return $res;
      }
      return $this->index_shard_settings;
    }
    public function clearIndexShardSettings() {
      if (isset($this->index_shard_settings)) {
        unset($this->index_shard_settings);
      }
    }
    public function hasIndexShardSettings() {
      return isset($this->index_shard_settings);
    }
    public function getIndexState() {
      if (!isset($this->index_state)) {
        return 0;
      }
      return $this->index_state;
    }
    public function setIndexState($val) {
      $this->index_state = $val;
      return $this;
    }
    public function clearIndexState() {
      unset($this->index_state);
      return $this;
    }
    public function hasIndexState() {
      return isset($this->index_state);
    }
    public function getIndexDeleteTime() {
      if (!isset($this->index_delete_time)) {
        return "0";
      }
      return $this->index_delete_time;
    }
    public function setIndexDeleteTime($val) {
      if (is_double($val)) {
        $this->index_delete_time = sprintf('%0.0F', $val);
      } else {
        $this->index_delete_time = $val;
      }
      return $this;
    }
    public function clearIndexDeleteTime() {
      unset($this->index_delete_time);
      return $this;
    }
    public function hasIndexDeleteTime() {
      return isset($this->index_delete_time);
    }
    public function getMaxIndexSizeBytes() {
      if (!isset($this->max_index_size_bytes)) {
        return "0";
      }
      return $this->max_index_size_bytes;
    }
    public function setMaxIndexSizeBytes($val) {
      if (is_double($val)) {
        $this->max_index_size_bytes = sprintf('%0.0F', $val);
      } else {
        $this->max_index_size_bytes = $val;
      }
      return $this;
    }
    public function clearMaxIndexSizeBytes() {
      unset($this->max_index_size_bytes);
      return $this;
    }
    public function hasMaxIndexSizeBytes() {
      return isset($this->max_index_size_bytes);
    }
    public function getReplicaDeletionSize() {
      return sizeof($this->replica_deletion);
    }
    public function getReplicaDeletionList() {
      return $this->replica_deletion;
    }
    public function mutableReplicaDeletion($idx) {
      if (!isset($this->replica_deletion[$idx])) {
        $val = new \storage_onestore_v3\IndexMetadata\IndexDeletionDetails();
        $this->replica_deletion[$idx] = $val;
        return $val;
      }
      return $this->replica_deletion[$idx];
    }
    public function getReplicaDeletion($idx) {
      if (isset($this->replica_deletion[$idx])) {
        return $this->replica_deletion[$idx];
      }
      if ($idx >= end(array_keys($this->replica_deletion))) {
        throw new \OutOfRangeException('index out of range: ' + $idx);
      }
      return new \storage_onestore_v3\IndexMetadata\IndexDeletionDetails();
    }
    public function addReplicaDeletion() {
      $val = new \storage_onestore_v3\IndexMetadata\IndexDeletionDetails();
      $this->replica_deletion[] = $val;
      return $val;
    }
    public function clearReplicaDeletion() {
      $this->replica_deletion = array();
    }
    public function clear() {
      $this->clearIsOverFieldNumberThreshold();
      $this->clearIndexShardSettings();
      $this->clearIndexState();
      $this->clearIndexDeleteTime();
      $this->clearMaxIndexSizeBytes();
      $this->clearReplicaDeletion();
    }
    public function byteSizePartial() {
      $res = 0;
      if (isset($this->is_over_field_number_threshold)) {
        $res += 2;
      }
      if (isset($this->index_shard_settings)) {
        $res += 1;
        $res += $this->lengthString($this->index_shard_settings->byteSizePartial());
      }
      if (isset($this->index_state)) {
        $res += 1;
        $res += $this->lengthVarInt64($this->index_state);
      }
      if (isset($this->index_delete_time)) {
        $res += 1;
        $res += $this->lengthVarInt64($this->index_delete_time);
      }
      if (isset($this->max_index_size_bytes)) {
        $res += 1;
        $res += $this->lengthVarInt64($this->max_index_size_bytes);
      }
      $this->checkProtoArray($this->replica_deletion);
      $res += 1 * sizeof($this->replica_deletion);
      foreach ($this->replica_deletion as $value) {
        $res += $this->lengthString($value->byteSizePartial());
      }
      return $res;
    }
    public function outputPartial($out) {
      if (isset($this->is_over_field_number_threshold)) {
        $out->putVarInt32(8);
        $out->putBoolean($this->is_over_field_number_threshold);
      }
      if (isset($this->index_shard_settings)) {
        $out->putVarInt32(18);
        $out->putVarInt32($this->index_shard_settings->byteSizePartial());
        $this->index_shard_settings->outputPartial($out);
      }
      if (isset($this->index_state)) {
        $out->putVarInt32(24);
        $out->putVarInt32($this->index_state);
      }
      if (isset($this->index_delete_time)) {
        $out->putVarInt32(32);
        $out->putVarInt64($this->index_delete_time);
      }
      if (isset($this->max_index_size_bytes)) {
        $out->putVarInt32(40);
        $out->putVarInt64($this->max_index_size_bytes);
      }
      $this->checkProtoArray($this->replica_deletion);
      foreach ($this->replica_deletion as $value) {
        $out->putVarInt32(50);
        $out->putVarInt32($value->byteSizePartial());
        $value->outputPartial($out);
      }
    }
    public function tryMerge($d) {
      while($d->avail() > 0) {
        $tt = $d->getVarInt32();
        switch ($tt) {
          case 8:
            $this->setIsOverFieldNumberThreshold($d->getBoolean());
            break;
          case 18:
            $length = $d->getVarInt32();
            $tmp = new \google\net\Decoder($d->buffer(), $d->pos(), $d->pos() + $length);
            $d->skip($length);
            $this->mutableIndexShardSettings()->tryMerge($tmp);
            break;
          case 24:
            $this->setIndexState($d->getVarInt32());
            break;
          case 32:
            $this->setIndexDeleteTime($d->getVarInt64());
            break;
          case 40:
            $this->setMaxIndexSizeBytes($d->getVarInt64());
            break;
          case 50:
            $length = $d->getVarInt32();
            $tmp = new \google\net\Decoder($d->buffer(), $d->pos(), $d->pos() + $length);
            $d->skip($length);
            $this->addReplicaDeletion()->tryMerge($tmp);
            break;
          case 0:
            throw new \google\net\ProtocolBufferDecodeError();
            break;
          default:
            $d->skipData($tt);
        }
      };
    }
    public function checkInitialized() {
      if (isset($this->index_shard_settings) && (!$this->index_shard_settings->isInitialized())) return 'index_shard_settings';
      foreach ($this->replica_deletion as $value) {
        if (!$value->isInitialized()) return 'replica_deletion';
      }
      return null;
    }
    public function mergeFrom($x) {
      if ($x === $this) { throw new \IllegalArgumentException('Cannot copy message to itself'); }
      if ($x->hasIsOverFieldNumberThreshold()) {
        $this->setIsOverFieldNumberThreshold($x->getIsOverFieldNumberThreshold());
      }
      if ($x->hasIndexShardSettings()) {
        $this->mutableIndexShardSettings()->mergeFrom($x->getIndexShardSettings());
      }
      if ($x->hasIndexState()) {
        $this->setIndexState($x->getIndexState());
      }
      if ($x->hasIndexDeleteTime()) {
        $this->setIndexDeleteTime($x->getIndexDeleteTime());
      }
      if ($x->hasMaxIndexSizeBytes()) {
        $this->setMaxIndexSizeBytes($x->getMaxIndexSizeBytes());
      }
      foreach ($x->getReplicaDeletionList() as $v) {
        $this->addReplicaDeletion()->copyFrom($v);
      }
    }
    public function equals($x) {
      if ($x === $this) { return true; }
      if (isset($this->is_over_field_number_threshold) !== isset($x->is_over_field_number_threshold)) return false;
      if (isset($this->is_over_field_number_threshold) && $this->is_over_field_number_threshold !== $x->is_over_field_number_threshold) return false;
      if (isset($this->index_shard_settings) !== isset($x->index_shard_settings)) return false;
      if (isset($this->index_shard_settings) && !$this->index_shard_settings->equals($x->index_shard_settings)) return false;
      if (isset($this->index_state) !== isset($x->index_state)) return false;
      if (isset($this->index_state) && $this->index_state !== $x->index_state) return false;
      if (isset($this->index_delete_time) !== isset($x->index_delete_time)) return false;
      if (isset($this->index_delete_time) && !$this->integerEquals($this->index_delete_time, $x->index_delete_time)) return false;
      if (isset($this->max_index_size_bytes) !== isset($x->max_index_size_bytes)) return false;
      if (isset($this->max_index_size_bytes) && !$this->integerEquals($this->max_index_size_bytes, $x->max_index_size_bytes)) return false;
      if (sizeof($this->replica_deletion) !== sizeof($x->replica_deletion)) return false;
      foreach (array_map(null, $this->replica_deletion, $x->replica_deletion) as $v) {
        if (!$v[0]->equals($v[1])) return false;
      }
      return true;
    }
    public function shortDebugString($prefix = "") {
      $res = '';
      if (isset($this->is_over_field_number_threshold)) {
        $res .= $prefix . "is_over_field_number_threshold: " . $this->debugFormatBool($this->is_over_field_number_threshold) . "\n";
      }
      if (isset($this->index_shard_settings)) {
        $res .= $prefix . "index_shard_settings <\n" . $this->index_shard_settings->shortDebugString($prefix . "  ") . $prefix . ">\n";
      }
      if (isset($this->index_state)) {
        $res .= $prefix . "index_state: " . ($this->index_state) . "\n";
      }
      if (isset($this->index_delete_time)) {
        $res .= $prefix . "index_delete_time: " . $this->debugFormatInt64($this->index_delete_time) . "\n";
      }
      if (isset($this->max_index_size_bytes)) {
        $res .= $prefix . "max_index_size_bytes: " . $this->debugFormatInt64($this->max_index_size_bytes) . "\n";
      }
      foreach ($this->replica_deletion as $value) {
        $res .= $prefix . "replica_deletion <\n" . $value->shortDebugString($prefix . "  ") . $prefix . ">\n";
      }
      return $res;
    }
  }
}
namespace storage_onestore_v3\FacetValue {
  class ContentType {
    const ATOM = 2;
    const NUMBER = 4;
  }
}
namespace storage_onestore_v3 {
  class FacetValue extends \google\net\ProtocolMessage {
    public function getType() {
      if (!isset($this->type)) {
        return 2;
      }
      return $this->type;
    }
    public function setType($val) {
      $this->type = $val;
      return $this;
    }
    public function clearType() {
      unset($this->type);
      return $this;
    }
    public function hasType() {
      return isset($this->type);
    }
    public function getStringValue() {
      if (!isset($this->string_value)) {
        return '';
      }
      return $this->string_value;
    }
    public function setStringValue($val) {
      $this->string_value = $val;
      return $this;
    }
    public function clearStringValue() {
      unset($this->string_value);
      return $this;
    }
    public function hasStringValue() {
      return isset($this->string_value);
    }
    public function clear() {
      $this->clearType();
      $this->clearStringValue();
    }
    public function byteSizePartial() {
      $res = 0;
      if (isset($this->type)) {
        $res += 1;
        $res += $this->lengthVarInt64($this->type);
      }
      if (isset($this->string_value)) {
        $res += 1;
        $res += $this->lengthString(strlen($this->string_value));
      }
      return $res;
    }
    public function outputPartial($out) {
      if (isset($this->type)) {
        $out->putVarInt32(8);
        $out->putVarInt32($this->type);
      }
      if (isset($this->string_value)) {
        $out->putVarInt32(26);
        $out->putPrefixedString($this->string_value);
      }
    }
    public function tryMerge($d) {
      while($d->avail() > 0) {
        $tt = $d->getVarInt32();
        switch ($tt) {
          case 8:
            $this->setType($d->getVarInt32());
            break;
          case 26:
            $length = $d->getVarInt32();
            $this->setStringValue(substr($d->buffer(), $d->pos(), $length));
            $d->skip($length);
            break;
          case 0:
            throw new \google\net\ProtocolBufferDecodeError();
            break;
          default:
            $d->skipData($tt);
        }
      };
    }
    public function checkInitialized() {
      return null;
    }
    public function mergeFrom($x) {
      if ($x === $this) { throw new \IllegalArgumentException('Cannot copy message to itself'); }
      if ($x->hasType()) {
        $this->setType($x->getType());
      }
      if ($x->hasStringValue()) {
        $this->setStringValue($x->getStringValue());
      }
    }
    public function equals($x) {
      if ($x === $this) { return true; }
      if (isset($this->type) !== isset($x->type)) return false;
      if (isset($this->type) && $this->type !== $x->type) return false;
      if (isset($this->string_value) !== isset($x->string_value)) return false;
      if (isset($this->string_value) && $this->string_value !== $x->string_value) return false;
      return true;
    }
    public function shortDebugString($prefix = "") {
      $res = '';
      if (isset($this->type)) {
        $res .= $prefix . "type: " . ($this->type) . "\n";
      }
      if (isset($this->string_value)) {
        $res .= $prefix . "string_value: " . $this->debugFormatString($this->string_value) . "\n";
      }
      return $res;
    }
  }
}
namespace storage_onestore_v3 {
  class Facet extends \google\net\ProtocolMessage {
    public function getName() {
      if (!isset($this->name)) {
        return '';
      }
      return $this->name;
    }
    public function setName($val) {
      $this->name = $val;
      return $this;
    }
    public function clearName() {
      unset($this->name);
      return $this;
    }
    public function hasName() {
      return isset($this->name);
    }
    public function getValue() {
      if (!isset($this->value)) {
        return new \storage_onestore_v3\FacetValue();
      }
      return $this->value;
    }
    public function mutableValue() {
      if (!isset($this->value)) {
        $res = new \storage_onestore_v3\FacetValue();
        $this->value = $res;
        return $res;
      }
      return $this->value;
    }
    public function clearValue() {
      if (isset($this->value)) {
        unset($this->value);
      }
    }
    public function hasValue() {
      return isset($this->value);
    }
    public function clear() {
      $this->clearName();
      $this->clearValue();
    }
    public function byteSizePartial() {
      $res = 0;
      if (isset($this->name)) {
        $res += 1;
        $res += $this->lengthString(strlen($this->name));
      }
      if (isset($this->value)) {
        $res += 1;
        $res += $this->lengthString($this->value->byteSizePartial());
      }
      return $res;
    }
    public function outputPartial($out) {
      if (isset($this->name)) {
        $out->putVarInt32(10);
        $out->putPrefixedString($this->name);
      }
      if (isset($this->value)) {
        $out->putVarInt32(18);
        $out->putVarInt32($this->value->byteSizePartial());
        $this->value->outputPartial($out);
      }
    }
    public function tryMerge($d) {
      while($d->avail() > 0) {
        $tt = $d->getVarInt32();
        switch ($tt) {
          case 10:
            $length = $d->getVarInt32();
            $this->setName(substr($d->buffer(), $d->pos(), $length));
            $d->skip($length);
            break;
          case 18:
            $length = $d->getVarInt32();
            $tmp = new \google\net\Decoder($d->buffer(), $d->pos(), $d->pos() + $length);
            $d->skip($length);
            $this->mutableValue()->tryMerge($tmp);
            break;
          case 0:
            throw new \google\net\ProtocolBufferDecodeError();
            break;
          default:
            $d->skipData($tt);
        }
      };
    }
    public function checkInitialized() {
      if (!isset($this->name)) return 'name';
      if ((!isset($this->value)) || (!$this->value->isInitialized())) return 'value';
      return null;
    }
    public function mergeFrom($x) {
      if ($x === $this) { throw new \IllegalArgumentException('Cannot copy message to itself'); }
      if ($x->hasName()) {
        $this->setName($x->getName());
      }
      if ($x->hasValue()) {
        $this->mutableValue()->mergeFrom($x->getValue());
      }
    }
    public function equals($x) {
      if ($x === $this) { return true; }
      if (isset($this->name) !== isset($x->name)) return false;
      if (isset($this->name) && $this->name !== $x->name) return false;
      if (isset($this->value) !== isset($x->value)) return false;
      if (isset($this->value) && !$this->value->equals($x->value)) return false;
      return true;
    }
    public function shortDebugString($prefix = "") {
      $res = '';
      if (isset($this->name)) {
        $res .= $prefix . "name: " . $this->debugFormatString($this->name) . "\n";
      }
      if (isset($this->value)) {
        $res .= $prefix . "value <\n" . $this->value->shortDebugString($prefix . "  ") . $prefix . ">\n";
      }
      return $res;
    }
  }
}
namespace storage_onestore_v3 {
  class DocumentMetadata extends \google\net\ProtocolMessage {
    public function getVersion() {
      if (!isset($this->version)) {
        return "0";
      }
      return $this->version;
    }
    public function setVersion($val) {
      if (is_double($val)) {
        $this->version = sprintf('%0.0F', $val);
      } else {
        $this->version = $val;
      }
      return $this;
    }
    public function clearVersion() {
      unset($this->version);
      return $this;
    }
    public function hasVersion() {
      return isset($this->version);
    }
    public function getCommittedStVersion() {
      if (!isset($this->committed_st_version)) {
        return "0";
      }
      return $this->committed_st_version;
    }
    public function setCommittedStVersion($val) {
      if (is_double($val)) {
        $this->committed_st_version = sprintf('%0.0F', $val);
      } else {
        $this->committed_st_version = $val;
      }
      return $this;
    }
    public function clearCommittedStVersion() {
      unset($this->committed_st_version);
      return $this;
    }
    public function hasCommittedStVersion() {
      return isset($this->committed_st_version);
    }
    public function clear() {
      $this->clearVersion();
      $this->clearCommittedStVersion();
    }
    public function byteSizePartial() {
      $res = 0;
      if (isset($this->version)) {
        $res += 1;
        $res += $this->lengthVarInt64($this->version);
      }
      if (isset($this->committed_st_version)) {
        $res += 1;
        $res += $this->lengthVarInt64($this->committed_st_version);
      }
      return $res;
    }
    public function outputPartial($out) {
      if (isset($this->version)) {
        $out->putVarInt32(8);
        $out->putVarInt64($this->version);
      }
      if (isset($this->committed_st_version)) {
        $out->putVarInt32(16);
        $out->putVarInt64($this->committed_st_version);
      }
    }
    public function tryMerge($d) {
      while($d->avail() > 0) {
        $tt = $d->getVarInt32();
        switch ($tt) {
          case 8:
            $this->setVersion($d->getVarInt64());
            break;
          case 16:
            $this->setCommittedStVersion($d->getVarInt64());
            break;
          case 0:
            throw new \google\net\ProtocolBufferDecodeError();
            break;
          default:
            $d->skipData($tt);
        }
      };
    }
    public function checkInitialized() {
      return null;
    }
    public function mergeFrom($x) {
      if ($x === $this) { throw new \IllegalArgumentException('Cannot copy message to itself'); }
      if ($x->hasVersion()) {
        $this->setVersion($x->getVersion());
      }
      if ($x->hasCommittedStVersion()) {
        $this->setCommittedStVersion($x->getCommittedStVersion());
      }
    }
    public function equals($x) {
      if ($x === $this) { return true; }
      if (isset($this->version) !== isset($x->version)) return false;
      if (isset($this->version) && !$this->integerEquals($this->version, $x->version)) return false;
      if (isset($this->committed_st_version) !== isset($x->committed_st_version)) return false;
      if (isset($this->committed_st_version) && !$this->integerEquals($this->committed_st_version, $x->committed_st_version)) return false;
      return true;
    }
    public function shortDebugString($prefix = "") {
      $res = '';
      if (isset($this->version)) {
        $res .= $prefix . "version: " . $this->debugFormatInt64($this->version) . "\n";
      }
      if (isset($this->committed_st_version)) {
        $res .= $prefix . "committed_st_version: " . $this->debugFormatInt64($this->committed_st_version) . "\n";
      }
      return $res;
    }
  }
}
namespace storage_onestore_v3\Document {
  class OrderIdSource {
    const DEFAULTED = 0;
    const SUPPLIED = 1;
  }
}
namespace storage_onestore_v3\Document {
  class Storage {
    const DISK = 0;
  }
}
namespace storage_onestore_v3 {
  class Document extends \google\net\ProtocolMessage {
    private $field = array();
    private $facet = array();
    public function getId() {
      if (!isset($this->id)) {
        return '';
      }
      return $this->id;
    }
    public function setId($val) {
      $this->id = $val;
      return $this;
    }
    public function clearId() {
      unset($this->id);
      return $this;
    }
    public function hasId() {
      return isset($this->id);
    }
    public function getLanguage() {
      if (!isset($this->language)) {
        return "en";
      }
      return $this->language;
    }
    public function setLanguage($val) {
      $this->language = $val;
      return $this;
    }
    public function clearLanguage() {
      unset($this->language);
      return $this;
    }
    public function hasLanguage() {
      return isset($this->language);
    }
    public function getFieldSize() {
      return sizeof($this->field);
    }
    public function getFieldList() {
      return $this->field;
    }
    public function mutableField($idx) {
      if (!isset($this->field[$idx])) {
        $val = new \storage_onestore_v3\Field();
        $this->field[$idx] = $val;
        return $val;
      }
      return $this->field[$idx];
    }
    public function getField($idx) {
      if (isset($this->field[$idx])) {
        return $this->field[$idx];
      }
      if ($idx >= end(array_keys($this->field))) {
        throw new \OutOfRangeException('index out of range: ' + $idx);
      }
      return new \storage_onestore_v3\Field();
    }
    public function addField() {
      $val = new \storage_onestore_v3\Field();
      $this->field[] = $val;
      return $val;
    }
    public function clearField() {
      $this->field = array();
    }
    public function getOrderId() {
      if (!isset($this->order_id)) {
        return 0;
      }
      return $this->order_id;
    }
    public function setOrderId($val) {
      $this->order_id = $val;
      return $this;
    }
    public function clearOrderId() {
      unset($this->order_id);
      return $this;
    }
    public function hasOrderId() {
      return isset($this->order_id);
    }
    public function getStorage() {
      if (!isset($this->storage)) {
        return 0;
      }
      return $this->storage;
    }
    public function setStorage($val) {
      $this->storage = $val;
      return $this;
    }
    public function clearStorage() {
      unset($this->storage);
      return $this;
    }
    public function hasStorage() {
      return isset($this->storage);
    }
    public function getOrderIdSource() {
      if (!isset($this->order_id_source)) {
        return 1;
      }
      return $this->order_id_source;
    }
    public function setOrderIdSource($val) {
      $this->order_id_source = $val;
      return $this;
    }
    public function clearOrderIdSource() {
      unset($this->order_id_source);
      return $this;
    }
    public function hasOrderIdSource() {
      return isset($this->order_id_source);
    }
    public function getFacetSize() {
      return sizeof($this->facet);
    }
    public function getFacetList() {
      return $this->facet;
    }
    public function mutableFacet($idx) {
      if (!isset($this->facet[$idx])) {
        $val = new \storage_onestore_v3\Facet();
        $this->facet[$idx] = $val;
        return $val;
      }
      return $this->facet[$idx];
    }
    public function getFacet($idx) {
      if (isset($this->facet[$idx])) {
        return $this->facet[$idx];
      }
      if ($idx >= end(array_keys($this->facet))) {
        throw new \OutOfRangeException('index out of range: ' + $idx);
      }
      return new \storage_onestore_v3\Facet();
    }
    public function addFacet() {
      $val = new \storage_onestore_v3\Facet();
      $this->facet[] = $val;
      return $val;
    }
    public function clearFacet() {
      $this->facet = array();
    }
    public function clear() {
      $this->clearId();
      $this->clearLanguage();
      $this->clearField();
      $this->clearOrderId();
      $this->clearStorage();
      $this->clearOrderIdSource();
      $this->clearFacet();
    }
    public function byteSizePartial() {
      $res = 0;
      if (isset($this->id)) {
        $res += 1;
        $res += $this->lengthString(strlen($this->id));
      }
      if (isset($this->language)) {
        $res += 1;
        $res += $this->lengthString(strlen($this->language));
      }
      $this->checkProtoArray($this->field);
      $res += 1 * sizeof($this->field);
      foreach ($this->field as $value) {
        $res += $this->lengthString($value->byteSizePartial());
      }
      if (isset($this->order_id)) {
        $res += 1;
        $res += $this->lengthVarInt64($this->order_id);
      }
      if (isset($this->storage)) {
        $res += 1;
        $res += $this->lengthVarInt64($this->storage);
      }
      if (isset($this->order_id_source)) {
        $res += 1;
        $res += $this->lengthVarInt64($this->order_id_source);
      }
      $this->checkProtoArray($this->facet);
      $res += 1 * sizeof($this->facet);
      foreach ($this->facet as $value) {
        $res += $this->lengthString($value->byteSizePartial());
      }
      return $res;
    }
    public function outputPartial($out) {
      if (isset($this->id)) {
        $out->putVarInt32(10);
        $out->putPrefixedString($this->id);
      }
      if (isset($this->language)) {
        $out->putVarInt32(18);
        $out->putPrefixedString($this->language);
      }
      $this->checkProtoArray($this->field);
      foreach ($this->field as $value) {
        $out->putVarInt32(26);
        $out->putVarInt32($value->byteSizePartial());
        $value->outputPartial($out);
      }
      if (isset($this->order_id)) {
        $out->putVarInt32(32);
        $out->putVarInt32($this->order_id);
      }
      if (isset($this->storage)) {
        $out->putVarInt32(40);
        $out->putVarInt32($this->storage);
      }
      if (isset($this->order_id_source)) {
        $out->putVarInt32(48);
        $out->putVarInt32($this->order_id_source);
      }
      $this->checkProtoArray($this->facet);
      foreach ($this->facet as $value) {
        $out->putVarInt32(66);
        $out->putVarInt32($value->byteSizePartial());
        $value->outputPartial($out);
      }
    }
    public function tryMerge($d) {
      while($d->avail() > 0) {
        $tt = $d->getVarInt32();
        switch ($tt) {
          case 10:
            $length = $d->getVarInt32();
            $this->setId(substr($d->buffer(), $d->pos(), $length));
            $d->skip($length);
            break;
          case 18:
            $length = $d->getVarInt32();
            $this->setLanguage(substr($d->buffer(), $d->pos(), $length));
            $d->skip($length);
            break;
          case 26:
            $length = $d->getVarInt32();
            $tmp = new \google\net\Decoder($d->buffer(), $d->pos(), $d->pos() + $length);
            $d->skip($length);
            $this->addField()->tryMerge($tmp);
            break;
          case 32:
            $this->setOrderId($d->getVarInt32());
            break;
          case 40:
            $this->setStorage($d->getVarInt32());
            break;
          case 48:
            $this->setOrderIdSource($d->getVarInt32());
            break;
          case 66:
            $length = $d->getVarInt32();
            $tmp = new \google\net\Decoder($d->buffer(), $d->pos(), $d->pos() + $length);
            $d->skip($length);
            $this->addFacet()->tryMerge($tmp);
            break;
          case 0:
            throw new \google\net\ProtocolBufferDecodeError();
            break;
          default:
            $d->skipData($tt);
        }
      };
    }
    public function checkInitialized() {
      foreach ($this->field as $value) {
        if (!$value->isInitialized()) return 'field';
      }
      foreach ($this->facet as $value) {
        if (!$value->isInitialized()) return 'facet';
      }
      return null;
    }
    public function mergeFrom($x) {
      if ($x === $this) { throw new \IllegalArgumentException('Cannot copy message to itself'); }
      if ($x->hasId()) {
        $this->setId($x->getId());
      }
      if ($x->hasLanguage()) {
        $this->setLanguage($x->getLanguage());
      }
      foreach ($x->getFieldList() as $v) {
        $this->addField()->copyFrom($v);
      }
      if ($x->hasOrderId()) {
        $this->setOrderId($x->getOrderId());
      }
      if ($x->hasStorage()) {
        $this->setStorage($x->getStorage());
      }
      if ($x->hasOrderIdSource()) {
        $this->setOrderIdSource($x->getOrderIdSource());
      }
      foreach ($x->getFacetList() as $v) {
        $this->addFacet()->copyFrom($v);
      }
    }
    public function equals($x) {
      if ($x === $this) { return true; }
      if (isset($this->id) !== isset($x->id)) return false;
      if (isset($this->id) && $this->id !== $x->id) return false;
      if (isset($this->language) !== isset($x->language)) return false;
      if (isset($this->language) && $this->language !== $x->language) return false;
      if (sizeof($this->field) !== sizeof($x->field)) return false;
      foreach (array_map(null, $this->field, $x->field) as $v) {
        if (!$v[0]->equals($v[1])) return false;
      }
      if (isset($this->order_id) !== isset($x->order_id)) return false;
      if (isset($this->order_id) && !$this->integerEquals($this->order_id, $x->order_id)) return false;
      if (isset($this->storage) !== isset($x->storage)) return false;
      if (isset($this->storage) && $this->storage !== $x->storage) return false;
      if (isset($this->order_id_source) !== isset($x->order_id_source)) return false;
      if (isset($this->order_id_source) && $this->order_id_source !== $x->order_id_source) return false;
      if (sizeof($this->facet) !== sizeof($x->facet)) return false;
      foreach (array_map(null, $this->facet, $x->facet) as $v) {
        if (!$v[0]->equals($v[1])) return false;
      }
      return true;
    }
    public function shortDebugString($prefix = "") {
      $res = '';
      if (isset($this->id)) {
        $res .= $prefix . "id: " . $this->debugFormatString($this->id) . "\n";
      }
      if (isset($this->language)) {
        $res .= $prefix . "language: " . $this->debugFormatString($this->language) . "\n";
      }
      foreach ($this->field as $value) {
        $res .= $prefix . "field <\n" . $value->shortDebugString($prefix . "  ") . $prefix . ">\n";
      }
      if (isset($this->order_id)) {
        $res .= $prefix . "order_id: " . $this->debugFormatInt32($this->order_id) . "\n";
      }
      if (isset($this->storage)) {
        $res .= $prefix . "storage: " . ($this->storage) . "\n";
      }
      if (isset($this->order_id_source)) {
        $res .= $prefix . "order_id_source: " . ($this->order_id_source) . "\n";
      }
      foreach ($this->facet as $value) {
        $res .= $prefix . "facet <\n" . $value->shortDebugString($prefix . "  ") . $prefix . ">\n";
      }
      return $res;
    }
  }
}
