/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.text;

/**
 * When an object of this type is attached to an Editable, its methods will
 * be called when the text is changed.
 */
public interface TextWatcher extends NoCopySpan {
  /**
   * This method is called to notify you that, within <code>s</code>,
   * the <code>count</code> characters beginning at <code>start</code>
   * are about to be replaced by new text with length <code>after</code>.
   * It is an error to attempt to make changes to <code>s</code> from
   * this callback.
   */
  public void beforeTextChanged(CharSequence s, int start,
      int count, int after);
  /**
   * This method is called to notify you that, within <code>s</code>,
   * the <code>count</code> characters beginning at <code>start</code>
   * have just replaced old text that had length <code>before</code>.
   * It is an error to attempt to make changes to <code>s</code> from
   * this callback.
   */
  public void onTextChanged(CharSequence s, int start, int before, int count);

  /**
   * This method is called to notify you that, somewhere within
   * <code>s</code>, the text has been changed.
   * It is legitimate to make further changes to <code>s</code> from
   * this callback, but be careful not to get yourself into an infinite
   * loop, because any changes you make will cause this method to be
   * called again recursively.
   * (You are not told where the change took place because other
   * afterTextChanged() methods may already have made other changes
   * and invalidated the offsets.  But if you need to know here,
   * you can use {@link Spannable#setSpan} in {@link #onTextChanged}
   * to mark your place and then look up from here where the span
   * ended up.
   */
  public void afterTextChanged(Editable s);
}
