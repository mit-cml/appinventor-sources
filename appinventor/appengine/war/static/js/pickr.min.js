/*! Pickr 1.8.0 MIT | https://github.com/Simonwep/pickr */ !(function (t, e) {
  "object" == typeof exports && "object" == typeof module
    ? (module.exports = e())
    : "function" == typeof define && define.amd
    ? define([], e)
    : "object" == typeof exports
    ? (exports.Pickr = e())
    : (t.Pickr = e());
})(window, function () {
  return (function (t) {
    var e = {};

    function o(n) {
      if (e[n]) return e[n].exports;
      var i = (e[n] = {
        i: n,
        l: !1,
        exports: {},
      });
      return t[n].call(i.exports, i, i.exports, o), (i.l = !0), i.exports;
    }
    return (
      (o.m = t),
      (o.c = e),
      (o.d = function (t, e, n) {
        o.o(t, e) ||
          Object.defineProperty(t, e, {
            enumerable: !0,
            get: n,
          });
      }),
      (o.r = function (t) {
        "undefined" != typeof Symbol &&
          Symbol.toStringTag &&
          Object.defineProperty(t, Symbol.toStringTag, {
            value: "Module",
          }),
          Object.defineProperty(t, "__esModule", {
            value: !0,
          });
      }),
      (o.t = function (t, e) {
        if ((1 & e && (t = o(t)), 8 & e)) return t;
        if (4 & e && "object" == typeof t && t && t.__esModule) return t;
        var n = Object.create(null);
        if (
          (o.r(n),
          Object.defineProperty(n, "default", {
            enumerable: !0,
            value: t,
          }),
          2 & e && "string" != typeof t)
        )
          for (var i in t)
            o.d(
              n,
              i,
              function (e) {
                return t[e];
              }.bind(null, i)
            );
        return n;
      }),
      (o.n = function (t) {
        var e =
          t && t.__esModule
            ? function () {
                return t.default;
              }
            : function () {
                return t;
              };
        return o.d(e, "a", e), e;
      }),
      (o.o = function (t, e) {
        return Object.prototype.hasOwnProperty.call(t, e);
      }),
      (o.p = ""),
      o((o.s = 0))
    );
  })([
    function (t, e, o) {
      "use strict";
      o.r(e);
      var n = {};

      function i(t, e, o, n, i = {}) {
        e instanceof HTMLCollection || e instanceof NodeList
          ? (e = Array.from(e))
          : Array.isArray(e) || (e = [e]),
          Array.isArray(o) || (o = [o]);
        for (const r of e)
          for (const e of o)
            r[t](e, n, {
              capture: !1,
              ...i,
            });
        return Array.prototype.slice.call(arguments, 1);
      }
      o.r(n),
        o.d(n, "on", function () {
          return r;
        }),
        o.d(n, "off", function () {
          return s;
        }),
        o.d(n, "createElementFromString", function () {
          return a;
        }),
        o.d(n, "createFromTemplate", function () {
          return l;
        }),
        o.d(n, "eventPath", function () {
          return c;
        }),
        o.d(n, "resolveElement", function () {
          return p;
        }),
        o.d(n, "adjustableInputNumbers", function () {
          return u;
        });
      const r = i.bind(null, "addEventListener"),
        s = i.bind(null, "removeEventListener");

      function a(t) {
        const e = document.createElement("div");
        return (e.innerHTML = t.trim()), e.firstElementChild;
      }

      function l(t) {
        const e = (t, e) => {
            const o = t.getAttribute(e);
            return t.removeAttribute(e), o;
          },
          o = (t, n = {}) => {
            const i = e(t, ":obj"),
              r = e(t, ":ref"),
              s = i ? (n[i] = {}) : n;
            r && (n[r] = t);
            for (const n of Array.from(t.children)) {
              const t = e(n, ":arr"),
                i = o(n, t ? {} : s);
              t && (s[t] || (s[t] = [])).push(Object.keys(i).length ? i : n);
            }
            return n;
          };
        return o(a(t));
      }

      function c(t) {
        let e = t.path || (t.composedPath && t.composedPath());
        if (e) return e;
        let o = t.target.parentElement;
        for (e = [t.target, o]; (o = o.parentElement); ) e.push(o);
        return e.push(document, window), e;
      }

      function p(t) {
        return t instanceof Element
          ? t
          : "string" == typeof t
          ? t
              .split(/>>/g)
              .reduce(
                (t, e, o, n) => (
                  (t = t.querySelector(e)), o < n.length - 1 ? t.shadowRoot : t
                ),
                document
              )
          : null;
      }

      function u(t, e = (t) => t) {
        function o(o) {
          const n =
            [0.001, 0.01, 0.1][Number(o.shiftKey || 2 * o.ctrlKey)] *
            (o.deltaY < 0 ? 1 : -1);
          let i = 0,
            r = t.selectionStart;
          (t.value = t.value.replace(/[\d.]+/g, (t, o) =>
            o <= r && o + t.length >= r
              ? ((r = o), e(Number(t), n, i))
              : (i++, t)
          )),
            t.focus(),
            t.setSelectionRange(r, r),
            o.preventDefault(),
            t.dispatchEvent(new Event("input"));
        }
        r(t, "focus", () =>
          r(window, "wheel", o, {
            passive: !1,
          })
        ),
          r(t, "blur", () => s(window, "wheel", o));
      }
      const { min: h, max: d, floor: f, round: m } = Math;

      function v(t, e, o) {
        (e /= 100), (o /= 100);
        const n = f((t = (t / 360) * 6)),
          i = t - n,
          r = o * (1 - e),
          s = o * (1 - i * e),
          a = o * (1 - (1 - i) * e),
          l = n % 6;
        return [
          255 * [o, s, r, r, a, o][l],
          255 * [a, o, o, s, r, r][l],
          255 * [r, r, a, o, o, s][l],
        ];
      }

      function b(t, e, o) {
        const n = ((2 - (e /= 100)) * (o /= 100)) / 2;
        return (
          0 !== n &&
            (e =
              1 === n
                ? 0
                : n < 0.5
                ? (e * o) / (2 * n)
                : (e * o) / (2 - 2 * n)),
          [t, 100 * e, 100 * n]
        );
      }

      function g(t, e, o) {
        const n = h((t /= 255), (e /= 255), (o /= 255)),
          i = d(t, e, o),
          r = i - n;
        let s, a;
        if (0 === r) s = a = 0;
        else {
          a = r / i;
          const n = ((i - t) / 6 + r / 2) / r,
            l = ((i - e) / 6 + r / 2) / r,
            c = ((i - o) / 6 + r / 2) / r;
          t === i
            ? (s = c - l)
            : e === i
            ? (s = 1 / 3 + n - c)
            : o === i && (s = 2 / 3 + l - n),
            s < 0 ? (s += 1) : s > 1 && (s -= 1);
        }
        return [360 * s, 100 * a, 100 * i];
      }

      function y(t, e, o, n) {
        (e /= 100), (o /= 100);
        return [
          ...g(
            255 * (1 - h(1, (t /= 100) * (1 - (n /= 100)) + n)),
            255 * (1 - h(1, e * (1 - n) + n)),
            255 * (1 - h(1, o * (1 - n) + n))
          ),
        ];
      }

      function _(t, e, o) {
        e /= 100;
        const n = ((2 * (e *= (o /= 100) < 0.5 ? o : 1 - o)) / (o + e)) * 100,
          i = 100 * (o + e);
        return [t, isNaN(n) ? 0 : n, i];
      }

      function w(t) {
        return g(...t.match(/.{2}/g).map((t) => parseInt(t, 16)));
      }

      function A(t) {
        t = t.match(/^[a-zA-Z]+$/)
          ? (function (t) {
              if ("black" === t.toLowerCase()) return "#000";
              const e = document.createElement("canvas").getContext("2d");
              return (
                (e.fillStyle = t), "#000" === e.fillStyle ? null : e.fillStyle
              );
            })(t)
          : t;
        const e = {
            cmyk: /^cmyk[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)/i,
            rgba: /^((rgba)|rgb)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]*?([\d.]+|$)/i,
            hsla: /^((hsla)|hsl)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]*?([\d.]+|$)/i,
            hsva: /^((hsva)|hsv)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]*?([\d.]+|$)/i,
            hexa: /^#?(([\dA-Fa-f]{3,4})|([\dA-Fa-f]{6})|([\dA-Fa-f]{8}))$/i,
          },
          o = (t) =>
            t.map((t) => (/^(|\d+)\.\d+|\d+$/.test(t) ? Number(t) : void 0));
        let n;
        t: for (const i in e) {
          if (!(n = e[i].exec(t))) continue;
          const r = (t) => !!n[2] == ("number" == typeof t);
          switch (i) {
            case "cmyk": {
              const [, t, e, r, s] = o(n);
              if (t > 100 || e > 100 || r > 100 || s > 100) break t;
              return {
                values: y(t, e, r, s),
                type: i,
              };
            }
            case "rgba": {
              const [, , , t, e, s, a] = o(n);
              if (t > 255 || e > 255 || s > 255 || a < 0 || a > 1 || !r(a))
                break t;
              return {
                values: [...g(t, e, s), a],
                a: a,
                type: i,
              };
            }
            case "hexa": {
              let [, t] = n;
              (4 !== t.length && 3 !== t.length) ||
                (t = t
                  .split("")
                  .map((t) => t + t)
                  .join(""));
              const e = t.substring(0, 6);
              let o = t.substring(6);
              return (
                (o = o ? parseInt(o, 16) / 255 : void 0),
                {
                  values: [...w(e), o],
                  a: o,
                  type: i,
                }
              );
            }
            case "hsla": {
              const [, , , t, e, s, a] = o(n);
              if (t > 360 || e > 100 || s > 100 || a < 0 || a > 1 || !r(a))
                break t;
              return {
                values: [..._(t, e, s), a],
                a: a,
                type: i,
              };
            }
            case "hsva": {
              const [, , , t, e, s, a] = o(n);
              if (t > 360 || e > 100 || s > 100 || a < 0 || a > 1 || !r(a))
                break t;
              return {
                values: [t, e, s, a],
                a: a,
                type: i,
              };
            }
          }
        }
        return {
          values: null,
          type: null,
        };
      }

      function C(t = 0, e = 0, o = 0, n = 1) {
        const i =
            (t, e) =>
            (o = -1) =>
              e(~o ? t.map((t) => Number(t.toFixed(o))) : t),
          r = {
            h: t,
            s: e,
            v: o,
            a: n,
            toHSVA() {
              const t = [r.h, r.s, r.v, r.a];
              return (
                (t.toString = i(
                  t,
                  (t) => `hsva(${t[0]}, ${t[1]}%, ${t[2]}%, ${r.a})`
                )),
                t
              );
            },
            toHSLA() {
              const t = [...b(r.h, r.s, r.v), r.a];
              return (
                (t.toString = i(
                  t,
                  (t) => `hsla(${t[0]}, ${t[1]}%, ${t[2]}%, ${r.a})`
                )),
                t
              );
            },
            toRGBA() {
              const t = [...v(r.h, r.s, r.v), r.a];
              return (
                (t.toString = i(
                  t,
                  (t) => `rgba(${t[0]}, ${t[1]}, ${t[2]}, ${r.a})`
                )),
                t
              );
            },
            toCMYK() {
              const t = (function (t, e, o) {
                const n = v(t, e, o),
                  i = n[0] / 255,
                  r = n[1] / 255,
                  s = n[2] / 255,
                  a = h(1 - i, 1 - r, 1 - s);
                return [
                  100 * (1 === a ? 0 : (1 - i - a) / (1 - a)),
                  100 * (1 === a ? 0 : (1 - r - a) / (1 - a)),
                  100 * (1 === a ? 0 : (1 - s - a) / (1 - a)),
                  100 * a,
                ];
              })(r.h, r.s, r.v);
              return (
                (t.toString = i(
                  t,
                  (t) => `cmyk(${t[0]}%, ${t[1]}%, ${t[2]}%, ${t[3]}%)`
                )),
                t
              );
            },
            toHEXA() {
              const t = (function (t, e, o) {
                  return v(t, e, o).map((t) =>
                    m(t).toString(16).padStart(2, "0")
                  );
                })(r.h, r.s, r.v),
                e =
                  r.a >= 1
                    ? ""
                    : Number((255 * r.a).toFixed(0))
                        .toString(16)
                        .toUpperCase()
                        .padStart(2, "0");
              return (
                e && t.push(e),
                (t.toString = () => "#" + t.join("").toUpperCase()),
                t
              );
            },
            clone: () => C(r.h, r.s, r.v, r.a),
          };
        return r;
      }
      const k = (t) => Math.max(Math.min(t, 1), 0);

      function $(t) {
        const e = {
            options: Object.assign(
              {
                lock: null,
                onchange: () => 0,
                onstop: () => 0,
              },
              t
            ),
            _keyboard(t) {
              const { options: o } = e,
                { type: n, key: i } = t;
              if (document.activeElement === o.wrapper) {
                const { lock: o } = e.options,
                  r = "ArrowUp" === i,
                  s = "ArrowRight" === i,
                  a = "ArrowDown" === i,
                  l = "ArrowLeft" === i;
                if ("keydown" === n && (r || s || a || l)) {
                  let n = 0,
                    i = 0;
                  "v" === o
                    ? (n = r || s ? 1 : -1)
                    : "h" === o
                    ? (n = r || s ? -1 : 1)
                    : ((i = r ? -1 : a ? 1 : 0), (n = l ? -1 : s ? 1 : 0)),
                    e.update(k(e.cache.x + 0.01 * n), k(e.cache.y + 0.01 * i)),
                    t.preventDefault();
                } else
                  i.startsWith("Arrow") &&
                    (e.options.onstop(), t.preventDefault());
              }
            },
            _tapstart(t) {
              r(document, ["mouseup", "touchend", "touchcancel"], e._tapstop),
                r(document, ["mousemove", "touchmove"], e._tapmove),
                t.cancelable && t.preventDefault(),
                e._tapmove(t);
            },
            _tapmove(t) {
              const { options: o, cache: n } = e,
                { lock: i, element: r, wrapper: s } = o,
                a = s.getBoundingClientRect();
              let l = 0,
                c = 0;
              if (t) {
                const e = t && t.touches && t.touches[0];
                (l = t ? (e || t).clientX : 0),
                  (c = t ? (e || t).clientY : 0),
                  l < a.left
                    ? (l = a.left)
                    : l > a.left + a.width && (l = a.left + a.width),
                  c < a.top
                    ? (c = a.top)
                    : c > a.top + a.height && (c = a.top + a.height),
                  (l -= a.left),
                  (c -= a.top);
              } else n && ((l = n.x * a.width), (c = n.y * a.height));
              "h" !== i &&
                (r.style.left = `calc(${(l / a.width) * 100}% - ${
                  r.offsetWidth / 2
                }px)`),
                "v" !== i &&
                  (r.style.top = `calc(${(c / a.height) * 100}% - ${
                    r.offsetHeight / 2
                  }px)`),
                (e.cache = {
                  x: l / a.width,
                  y: c / a.height,
                });
              const p = k(l / a.width),
                u = k(c / a.height);
              switch (i) {
                case "v":
                  return o.onchange(p);
                case "h":
                  return o.onchange(u);
                default:
                  return o.onchange(p, u);
              }
            },
            _tapstop() {
              e.options.onstop(),
                s(document, ["mouseup", "touchend", "touchcancel"], e._tapstop),
                s(document, ["mousemove", "touchmove"], e._tapmove);
            },
            trigger() {
              e._tapmove();
            },
            update(t = 0, o = 0) {
              const {
                left: n,
                top: i,
                width: r,
                height: s,
              } = e.options.wrapper.getBoundingClientRect();
              "h" === e.options.lock && (o = t),
                e._tapmove({
                  clientX: n + r * t,
                  clientY: i + s * o,
                });
            },
            destroy() {
              const { options: t, _tapstart: o, _keyboard: n } = e;
              s(document, ["keydown", "keyup"], n),
                s([t.wrapper, t.element], "mousedown", o),
                s([t.wrapper, t.element], "touchstart", o, {
                  passive: !1,
                });
            },
          },
          { options: o, _tapstart: n, _keyboard: i } = e;
        return (
          r([o.wrapper, o.element], "mousedown", n),
          r([o.wrapper, o.element], "touchstart", n, {
            passive: !1,
          }),
          r(document, ["keydown", "keyup"], i),
          e
        );
      }

      function S(t = {}) {
        t = Object.assign(
          {
            onchange: () => 0,
            className: "",
            elements: [],
          },
          t
        );
        const e = r(t.elements, "click", (e) => {
          t.elements.forEach((o) =>
            o.classList[e.target === o ? "add" : "remove"](t.className)
          ),
            t.onchange(e),
            e.stopPropagation();
        });
        return {
          destroy: () => s(...e),
        };
      }
      /*! NanoPop 2.1.0 MIT | https://github.com/Simonwep/nanopop */
      const O = {
          variantFlipOrder: {
            start: "sme",
            middle: "mse",
            end: "ems",
          },
          positionFlipOrder: {
            top: "tbrl",
            right: "rltb",
            bottom: "btrl",
            left: "lrbt",
          },
          position: "bottom",
          margin: 8,
        },
        E = (t, e, o) => {
          const n =
            "object" != typeof t || t instanceof HTMLElement
              ? {
                  reference: t,
                  popper: e,
                  ...o,
                }
              : t;
          return {
            update(t = n) {
              const { reference: e, popper: o } = Object.assign(n, t);
              if (!o || !e)
                throw new Error("Popper- or reference-element missing.");
              return ((t, e, o) => {
                const {
                    container: n,
                    margin: i,
                    position: r,
                    variantFlipOrder: s,
                    positionFlipOrder: a,
                  } = {
                    container: document.documentElement.getBoundingClientRect(),
                    ...O,
                    ...o,
                  },
                  { left: l, top: c } = e.style;
                (e.style.left = "0"), (e.style.top = "0");
                const p = t.getBoundingClientRect(),
                  u = e.getBoundingClientRect(),
                  h = {
                    t: p.top - u.height - i,
                    b: p.bottom + i,
                    r: p.right + i,
                    l: p.left - u.width - i,
                  },
                  d = {
                    vs: p.left,
                    vm: p.left + p.width / 2 + -u.width / 2,
                    ve: p.left + p.width - u.width,
                    hs: p.top,
                    hm: p.bottom - p.height / 2 - u.height / 2,
                    he: p.bottom - u.height,
                  },
                  [f, m = "middle"] = r.split("-"),
                  v = a[f],
                  b = s[m],
                  { top: g, left: y, bottom: _, right: w } = n;
                for (const t of v) {
                  const o = "t" === t || "b" === t,
                    n = h[t],
                    [i, r] = o ? ["top", "left"] : ["left", "top"],
                    [s, a] = o ? [u.height, u.width] : [u.width, u.height],
                    [l, c] = o ? [_, w] : [w, _],
                    [p, f] = o ? [g, y] : [y, g];
                  if (!(n < p || n + s > l))
                    for (const s of b) {
                      const l = d[(o ? "v" : "h") + s];
                      if (!(l < f || l + a > c))
                        return (
                          (e.style[r] = l - u[r] + "px"),
                          (e.style[i] = n - u[i] + "px"),
                          t + s
                        );
                    }
                }
                return (e.style.left = l), (e.style.top = c), null;
              })(e, o, n);
            },
          };
        };

      function L(t, e, o) {
        return (
          e in t
            ? Object.defineProperty(t, e, {
                value: o,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (t[e] = o),
          t
        );
      }
      class x {
        constructor(t) {
          L(this, "_initializingActive", !0),
            L(this, "_recalc", !0),
            L(this, "_nanopop", null),
            L(this, "_root", null),
            L(this, "_color", C()),
            L(this, "_lastColor", C()),
            L(this, "_swatchColors", []),
            L(this, "_setupAnimationFrame", null),
            L(this, "selectedProjectColor", null),
            L(this, "_eventListener", {
              init: [],
              save: [],
              hide: [],
              show: [],
              clear: [],
              change: [],
              changestop: [],
              cancel: [],
              swatchselect: [],
            }),
            (this.options = t = Object.assign({ ...x.DEFAULT_OPTIONS }, t));
          const {
            swatches: e,
            swatches2: e2,
            components: o,
            theme: n,
            sliders: i,
            lockOpacity: r,
            padding: s,
          } = t;
          ["nano", "monolith"].includes(n) && !i && (t.sliders = "h"),
            o.interaction || (o.interaction = {});
          const { preview: a, opacity: l, hue: c, palette: p } = o;
          (o.opacity = !r && l),
            (o.palette = p || a || l || c),
            this._preBuild(),
            this._buildComponents(),
            this._bindEvents(),
            this._finalBuild(),
            e &&
              Object.keys(e).length &&
              Object.keys(e).forEach((t) => this.addSwatch(t, e[t])),
            e2 &&
              Object.keys(e2).length &&
              Object.keys(e2).forEach((t) => this.addSwatch2(t, e2[t]));
          const { button: u, app: h } = this._root;
          (this._nanopop = E(u, h, {
            margin: s,
          })),
            u.setAttribute("role", "button"),
            u.setAttribute("aria-label", this._t("btn:toggle"));
          const d = this;
          this._setupAnimationFrame = requestAnimationFrame(function e() {
            if (!h.offsetWidth) return requestAnimationFrame(e);
            d.setColor(t.default),
              d._rePositioningPicker(),
              t.defaultRepresentation &&
                ((d._representation = t.defaultRepresentation),
                d.setColorRepresentation(d._representation)),
              t.showAlways && d.show(),
              (d._initializingActive = !1),
              d._emit("init");
          });
        }
        _preBuild() {
          const { options: t } = this;
          for (const e of ["el", "container"]) t[e] = p(t[e]);
          (this._root = ((t) => {
            const {
                components: e,
                useAsButton: o,
                inline: n,
                appClass: i,
                theme: r,
                lockOpacity: s,
              } = t.options,
              a = (t) => (t ? "" : 'style="display:none" hidden'),
              c = (e) => t._t(e),
              p = l(
                `<div :ref="root" class="pickr"> ${
                  o
                    ? ""
                    : '<button type="button" :ref="button" class="pcr-button"></button>'
                } <div :ref="app" class="pcr-app ${
                  i || ""
                }" data-theme="${r}" ${
                  n ? 'style="position: unset"' : ""
                } aria-label="${c(" ui:dialog")}" role="window">
        <div class="pcr-selection" ${a(e.palette)}>
            <div :obj="preview" class="pcr-color-preview" ${a(
              e.preview
            )}> <button type="button" :ref="lastColor" class="pcr-last-color" aria-label="${c(
                  " btn:last-color"
                )}"></button>
                <div :ref="currentColor" class="pcr-current-color"></div>
            </div>
            <div :obj="palette" class="pcr-color-palette">
                <div :ref="picker" class="pcr-picker"></div>
                <div :ref="palette" class="pcr-palette" tabindex="0" aria-label="${c(
                  " aria:palette"
                )}" role="listbox"></div>
            </div>
            <div :obj="hue" class="pcr-color-chooser" ${a(e.hue)}>
                <div :ref="picker" class="pcr-picker"></div>
                <div :ref="slider" class="pcr-hue pcr-slider" tabindex="0" aria-label="${c(
                  " aria:hue"
                )}" role="slider"></div>
            </div>
            <div :obj="opacity" class="pcr-color-opacity" ${a(e.opacity)}>
                <div :ref="picker" class="pcr-picker"></div>
                <div :ref="slider" class="pcr-opacity pcr-slider" tabindex="0" aria-label="${c(
                  " aria:opacity"
                )}" role="slider"></div>
            </div>
        </div>
        <p class="colorPickerHeading">Default Colors</p>
        <div class="pcr-swatches ${
          e.palette ? "" : " pcr-last"
        }" :ref="swatches"></div>
        <p class="colorPickerHeading2">Project Colors</p>
        <div class="pcr-swatches project-colors ${
          e.palette ? "" : " pcr-last"
        }" :ref="swatches2"></div>
        <div :obj="interaction" class="pcr-interaction" ${a(
          4
        )}> <input :ref="result" class="pcr-result" type="text" spellcheck="false" ${a(
                  e.interaction.input
                )} aria-label="${c(
                  " aria:input"
                )}"> <input :arr="options" class="pcr-type" data-type="HEXA" value="${
                  s ? " HEX" : "HEXA"
                }" type="button" ${a(
                  e.interaction.hex
                )}> <input :arr="options" class="pcr-type" data-type="RGBA" value="${
                  s ? " RGB" : "RGBA"
                }" type="button" ${a(
                  e.interaction.rgba
                )}> <input :arr="options" class="pcr-type" data-type="HSLA" value="${
                  s ? " HSL" : "HSLA"
                }" type="button" ${a(
                  e.interaction.hsla
                )}> <input :arr="options" class="pcr-type" data-type="HSVA" value="${
                  s ? " HSV" : "HSVA"
                }" type="button" ${a(
                  e.interaction.hsva
                )}> <input :arr="options" class="pcr-type" data-type="CMYK" value="CMYK" type="button" ${a(
                  e.interaction.cmyk
                )}></div>
        <div :obj="buttons" class="pcr-interaction" ${a(
          2
        )}> <input :ref="save" class="pcr-save" value="Save" type="button" ${a(
                  e.interaction.save
                )} aria-label="save">
         <input :ref="cancel" class="pcr-cancel" value="Cancel" type="button" ${a(
           e.interaction.cancel
         )} aria-label="cancel"> </div>
    </div>
</div>`
              ),
              u = p.interaction;
            return (
              u.options.find((t) => !t.hidden && !t.classList.add("active")),
              (u.type = () =>
                u.options.find((t) => t.classList.contains("active"))),
              p
            );
          })(this)),
            t.useAsButton && (this._root.button = t.el),
            t.container.appendChild(this._root.root);
        }
        _finalBuild() {
          const t = this.options,
            e = this._root;
          if ((t.container.removeChild(e.root), t.inline)) {
            const o = t.el.parentElement;
            t.el.nextSibling
              ? o.insertBefore(e.app, t.el.nextSibling)
              : o.appendChild(e.app);
          } else t.container.appendChild(e.app);
          t.useAsButton
            ? t.inline && t.el.remove()
            : t.el.parentNode.replaceChild(e.root, t.el),
            t.disabled && this.disable(),
            t.comparison ||
              ((e.button.style.transition = "none"),
              t.useAsButton || (e.preview.lastColor.style.transition = "none")),
            this.hide();
        }
        _buildComponents() {
          const t = this,
            e = this.options.components,
            o = (t.options.sliders || "v").repeat(2),
            [n, i] = o.match(/^[vh]+$/g) ? o : [],
            r = () => this._color || (this._color = this._lastColor.clone()),
            s = {
              palette: $({
                element: t._root.palette.picker,
                wrapper: t._root.palette.palette,
                onstop: () => t._emit("changestop", "slider", t),
                onchange(o, n) {
                  if (!e.palette) return;
                  const i = r(),
                    { _root: s, options: a } = t,
                    { lastColor: l, currentColor: c } = s.preview;
                  t._recalc &&
                    ((i.s = 100 * o),
                    (i.v = 100 - 100 * n),
                    i.v < 0 && (i.v = 0),
                    t._updateOutput("slider"));
                  const p = i.toRGBA().toString(0);
                  (this.element.style.background = p),
                    (this.wrapper.style.background = `\n                        linear-gradient(to top, rgba(0, 0, 0, ${i.a}), transparent),\n                        linear-gradient(to left, hsla(${i.h}, 100%, 50%, ${i.a}), rgba(255, 255, 255, ${i.a}))\n                    `),
                    a.comparison
                      ? a.useAsButton || t._lastColor || (l.style.color = p)
                      : ((s.button.style.color = p),
                        s.button.classList.remove("clear"));
                  const u = i.toHEXA().toString();
                  for (const { el: e, color: o } of t._swatchColors)
                    e.classList[u === o.toHEXA().toString() ? "add" : "remove"](
                      "pcr-active"
                    );
                  c.style.color = p;
                },
              }),
              hue: $({
                lock: "v" === i ? "h" : "v",
                element: t._root.hue.picker,
                wrapper: t._root.hue.slider,
                onstop: () => t._emit("changestop", "slider", t),
                onchange(o) {
                  if (!e.hue || !e.palette) return;
                  const n = r();
                  t._recalc && (n.h = 360 * o),
                    (this.element.style.backgroundColor = `hsl(${n.h}, 100%, 50%)`),
                    s.palette.trigger();
                },
              }),
              opacity: $({
                lock: "v" === n ? "h" : "v",
                element: t._root.opacity.picker,
                wrapper: t._root.opacity.slider,
                onstop: () => t._emit("changestop", "slider", t),
                onchange(o) {
                  if (!e.opacity || !e.palette) return;
                  const n = r();
                  t._recalc && (n.a = Math.round(100 * o) / 100),
                    (this.element.style.background = `rgba(0, 0, 0, ${n.a})`),
                    s.palette.trigger();
                },
              }),
              selectable: S({
                elements: t._root.interaction.options,
                className: "active",
                onchange(e) {
                  (t._representation = e.target
                    .getAttribute("data-type")
                    .toUpperCase()),
                    t._recalc && t._updateOutput("swatch");
                },
              }),
            };
          this._components = s;
        }
        _bindEvents() {
          const { _root: t, options: e } = this,
            o = [
              r([t.buttons.cancel, t.preview.lastColor], "click", () => {
                this._emit("cancel");
              }),
              r(t.buttons.save, "click", () => {
                !this.applyColor() && !e.showAlways && this.hide();
              }),
              r(t.interaction.result, ["keyup", "input"], (t) => {
                this.setColor(t.target.value, !0) &&
                  !this._initializingActive &&
                  (this._emit("change", this._color, "input", this),
                  this._emit("changestop", "input", this)),
                  t.stopImmediatePropagation();
              }),
              r(t.interaction.result, ["focus", "blur"], (t) => {
                (this._recalc = "blur" === t.type),
                  this._recalc && this._updateOutput(null);
              }),
              r(
                [
                  t.palette.palette,
                  t.palette.picker,
                  t.hue.slider,
                  t.hue.picker,
                  t.opacity.slider,
                  t.opacity.picker,
                ],
                ["mousedown", "touchstart"],
                () => (this._recalc = !0),
                {
                  passive: !0,
                }
              ),
            ];
          if (!e.showAlways) {
            const n = e.closeWithKey;
            o.push(
              r(t.button, "click", () =>
                this.isOpen() ? this.hide() : this.show()
              ),
              r(
                document,
                "keyup",
                (t) =>
                  this.isOpen() && (t.key === n || t.code === n) && this.hide()
              ),
              r(
                document,
                ["touchstart", "mousedown"],
                (e) => {
                  this.isOpen() &&
                    !c(e).some((e) => e === t.app || e === t.button) &&
                    this.hide();
                },
                {
                  capture: !0,
                }
              )
            );
          }
          if (e.adjustableNumbers) {
            const e = {
              rgba: [255, 255, 255, 1],
              hsva: [360, 100, 100, 1],
              hsla: [360, 100, 100, 1],
              cmyk: [100, 100, 100, 100],
            };
            u(t.interaction.result, (t, o, n) => {
              const i = e[this.getColorRepresentation().toLowerCase()];
              if (i) {
                const e = i[n],
                  r = t + (e >= 100 ? 1e3 * o : o);
                return r <= 0 ? 0 : Number((r < e ? r : e).toPrecision(3));
              }
              return t;
            });
          }
          if (e.autoReposition && !e.inline) {
            let t = null;
            const n = this;
            o.push(
              r(
                window,
                ["scroll", "resize"],
                () => {
                  n.isOpen() &&
                    (e.closeOnScroll && n.hide(),
                    null === t
                      ? ((t = setTimeout(() => (t = null), 100)),
                        requestAnimationFrame(function e() {
                          n._rePositioningPicker(),
                            null !== t && requestAnimationFrame(e);
                        }))
                      : (clearTimeout(t),
                        (t = setTimeout(() => (t = null), 100))));
                },
                {
                  capture: !0,
                }
              )
            );
          }
          this._eventBindings = o;
        }
        _rePositioningPicker() {
          const { options: t } = this;
          if (!t.inline) {
            if (
              !this._nanopop.update({
                container: document.body.getBoundingClientRect(),
                position: t.position,
              })
            ) {
              const t = this._root.app,
                e = t.getBoundingClientRect();
              (t.style.top = (window.innerHeight - e.height) / 2 + "px"),
                (t.style.left = (window.innerWidth - e.width) / 2 + "px");
            }
          }
        }
        _updateOutput(t) {
          const { _root: e, _color: o, options: n } = this;
          if (e.interaction.type()) {
            const t = "to" + e.interaction.type().getAttribute("data-type");
            e.interaction.result.value =
              "function" == typeof o[t]
                ? o[t]().toString(n.outputPrecision)
                : "";
          }
          !this._initializingActive &&
            this._recalc &&
            this._emit("change", o, t, this);
        }
        _clearColor(t = !1) {
          const { _root: e, options: o } = this;
          o.useAsButton || (e.button.style.color = "rgba(0, 0, 0, 0.15)"),
            e.button.classList.add("clear"),
            o.showAlways || this.hide(),
            (this._lastColor = null),
            this._initializingActive ||
              t ||
              (this._emit("save", null), this._emit("clear"));
        }
        _parseLocalColor(t) {
          const { values: e, type: o, a: n } = A(t),
            { lockOpacity: i } = this.options,
            r = void 0 !== n && 1 !== n;
          return (
            e && 3 === e.length && (e[3] = void 0),
            {
              values: !e || (i && r) ? null : e,
              type: o,
            }
          );
        }
        _t(t) {
          return this.options.i18n[t] || x.I18N_DEFAULTS[t];
        }
        _emit(t, ...e) {
          this._eventListener[t].forEach((t) => t(...e, this));
        }
        on(t, e) {
          return this._eventListener[t].push(e), this;
        }
        off(t, e) {
          const o = this._eventListener[t] || [],
            n = o.indexOf(e);
          return ~n && o.splice(n, 1), this;
        }
        addSwatch(t, colorName) {
          const { values: e } = this._parseLocalColor(t);
          if (e) {
            const { _swatchColors: t, _root: o } = this,
              n = C(...e),
              element = document.createElement("div");
            element.dataset.color = n.toHEXA();
            element.className = "swatch-container";
            i = `<div><button type="button" style="color: ${n
              .toRGBA()
              .toString(
                0
              )}" aria-label="color-swatch"</button></div><p class="swatch-text">${colorName}</p>`;
            element.innerHTML = i;
            return (
              o.swatches.appendChild(element),
              t.push({
                el: element,
                color: n,
              }),
              this._eventBindings.push(
                r(element, "click", () => {
                  this.setHSVA(...n.toHSVA(), !0),
                    this._emit("swatchselect", n),
                    this._emit("change", n, "swatch", this);
                })
              ),
              !0
            );
          }
          return !1;
        }
        addSwatch2(t, colorName) {
          const colorValue = t;
          const { values: e } = this._parseLocalColor(t);
          if (e) {
            const { _swatchColors: t, _root: o } = this,
              n = C(...e),
              element = document.createElement("div");
            element.className = "swatch-container";
            i = `<div class="swatch-wrapper"><div><button type="button" style="color: ${n
              .toRGBA()
              .toString(0)}" aria-label="color-swatch"</button></div>
              <div class="delete-btn" title="Remove color">×</div>
              </div><p class="swatch-text">${colorName}</p>`;
            element.innerHTML = i;
            const deleteBtn = element.querySelector(".delete-btn");
            deleteBtn.addEventListener("click", function () {
              o.swatches2.removeChild(element);
              if (window.projectColorDeleted) {
                setTimeout(function () {
                  const defaultColor = document.querySelector(
                    '[data-color="#00000000"]'
                  );
                  if (defaultColor) {
                    defaultColor.click();
                  }
                }, 1);
                window.projectColorDeleted(colorValue);
              }
            });
            return (
              o.swatches2.appendChild(element),
              t.push({
                el: element,
                color: n,
              }),
              this._eventBindings.push(
                r(element, "click", () => {
                  // fetch previous selected color
                  const selectedProjColor = o.swatches2.querySelector(
                    ".project-colors .swatch-container.selected"
                  );
                  if (selectedProjColor) {
                    selectedProjColor.classList.remove("selected");
                  }
                  element.classList.add("selected");

                  this.setHSVA(...n.toHSVA(), !0);
                })
              ),
              !0
            );
          }
          return !1;
        }
        removeSwatch(t) {
          const e = this._swatchColors[t];
          if (e) {
            const { el: o } = e;
            return (
              this._root.swatches.removeChild(o),
              this._swatchColors.splice(t, 1),
              !0
            );
          }
          return !1;
        }
        applyColor(t = !1) {
          const { preview: e, button: o } = this._root,
            n = this._color.toRGBA().toString(0);
          return (
            (e.lastColor.style.color = n),
            this.options.useAsButton || (o.style.color = n),
            o.classList.remove("clear"),
            (this._lastColor = this._color.clone()),
            this._initializingActive || t || this._emit("save", this._color),
            this
          );
        }
        destroy() {
          cancelAnimationFrame(this._setupAnimationFrame),
            this._eventBindings.forEach((t) => s(...t)),
            Object.keys(this._components).forEach((t) =>
              this._components[t].destroy()
            );
        }
        destroyAndRemove() {
          this.destroy();
          const { root: t, app: e } = this._root;
          t.parentElement && t.parentElement.removeChild(t),
            e.parentElement.removeChild(e),
            Object.keys(this).forEach((t) => (this[t] = null));
        }
        hide() {
          return (
            this._root.app.classList.remove("visible"), this._emit("hide"), this
          );
        }
        show() {
          return (
            this.options.disabled ||
              (this._root.app.classList.add("visible"),
              this._rePositioningPicker(),
              this._emit("show", this._color)),
            this
          );
        }
        isOpen() {
          return this._root.app.classList.contains("visible");
        }
        setHSVA(t = 360, e = 0, o = 0, n = 1, i = !1) {
          const r = this._recalc;
          if (
            ((this._recalc = !1),
            t < 0 ||
              t > 360 ||
              e < 0 ||
              e > 100 ||
              o < 0 ||
              o > 100 ||
              n < 0 ||
              n > 1)
          )
            return !1;
          this._color = C(t, e, o, n);
          const { hue: s, opacity: a, palette: l } = this._components;
          return (
            s.update(t / 360),
            a.update(n),
            l.update(e / 100, 1 - o / 100),
            i || this.applyColor(),
            r && this._updateOutput(),
            (this._recalc = r),
            !0
          );
        }
        setColor(t, e = !1) {
          if (null === t) return this._clearColor(e), !0;
          const { values: o, type: n } = this._parseLocalColor(t);
          if (o) {
            const t = n.toUpperCase(),
              { options: i } = this._root.interaction,
              r = i.find((e) => e.getAttribute("data-type") === t);
            if (r && !r.hidden)
              for (const t of i)
                t.classList[t === r ? "add" : "remove"]("active");
            return !!this.setHSVA(...o, e) && this.setColorRepresentation(t);
          }
          return !1;
        }
        setColorRepresentation(t) {
          return (
            (t = t.toUpperCase()),
            !!this._root.interaction.options.find(
              (e) => e.getAttribute("data-type").startsWith(t) && !e.click()
            )
          );
        }
        getColorRepresentation() {
          return this._representation;
        }
        getColor() {
          return this._color;
        }
        getSelectedColor() {
          return this._lastColor;
        }
        getRoot() {
          return this._root;
        }
        disable() {
          return (
            this.hide(),
            (this.options.disabled = !0),
            this._root.button.classList.add("disabled"),
            this
          );
        }
        enable() {
          return (
            (this.options.disabled = !1),
            this._root.button.classList.remove("disabled"),
            this
          );
        }
      }
      L(x, "utils", n),
        L(x, "version", "1.8.0"),
        L(x, "I18N_DEFAULTS", {
          "ui:dialog": "color picker dialog",
          "btn:toggle": "toggle color picker dialog",
          "btn:swatch": "color swatch",
          "btn:last-color": "use previous color",
          "btn:save": "Save",
          "btn:cancel": "Cancel",
          "btn:clear": "Clear",
          "aria:btn:save": "save and close",
          "aria:btn:cancel": "cancel and close",
          "aria:btn:clear": "clear and close",
          "aria:input": "color input field",
          "aria:palette": "color selection area",
          "aria:hue": "hue selection slider",
          "aria:opacity": "selection slider",
        }),
        L(x, "DEFAULT_OPTIONS", {
          appClass: null,
          theme: "classic",
          useAsButton: !1,
          padding: 8,
          disabled: !1,
          comparison: !0,
          closeOnScroll: !1,
          outputPrecision: 0,
          lockOpacity: !1,
          autoReposition: !0,
          container: "body",
          components: {
            interaction: {},
          },
          i18n: {},
          swatches: null,
          inline: !1,
          sliders: null,
          default: "#42445a",
          defaultRepresentation: null,
          position: "bottom-middle",
          adjustableNumbers: !0,
          showAlways: !1,
          closeWithKey: "Escape",
        }),
        L(x, "create", (t) => new x(t));
      e.default = x;
    },
  ]).default;
});
